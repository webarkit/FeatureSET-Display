/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ARFset"] = factory();
	else
		root["ARFset"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack://ARFset/./node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/axios */ \"./node_modules/axios/lib/axios.js\");\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/index.js?");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/adapters/xhr.js?");

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\nvar Axios = __webpack_require__(/*! ./core/Axios */ \"./node_modules/axios/lib/core/Axios.js\");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \"./node_modules/axios/lib/cancel/CancelToken.js\");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\naxios.VERSION = (__webpack_require__(/*! ./env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \"./node_modules/axios/lib/helpers/spread.js\");\n\n// Expose isAxiosError\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \"./node_modules/axios/lib/helpers/isAxiosError.js\");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports[\"default\"] = axios;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/cancel/Cancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/cancel/CancelToken.js?");

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/cancel/isCancel.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\nvar validator = __webpack_require__(/*! ../helpers/validator */ \"./node_modules/axios/lib/helpers/validator.js\");\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/Axios.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/InterceptorManager.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \"./node_modules/axios/lib/helpers/isAbsoluteURL.js\");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \"./node_modules/axios/lib/helpers/combineURLs.js\");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/buildFullPath.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/createError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/dispatchRequest.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/enhanceError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/mergeConfig.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/settle.js?");

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar defaults = __webpack_require__(/*! ./../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/core/transformData.js?");

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\nvar enhanceError = __webpack_require__(/*! ./core/enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/defaults.js?");

/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = {\n  \"version\": \"0.24.0\"\n};\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/env/data.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/bind.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/buildURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/combineURLs.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/cookies.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/isAbsoluteURL.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/isAxiosError.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/isURLSameOrigin.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/normalizeHeaderName.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/parseHeaders.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/spread.js?");

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar VERSION = (__webpack_require__(/*! ../env/data */ \"./node_modules/axios/lib/env/data.js\").version);\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/helpers/validator.js?");

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n\n\n//# sourceURL=webpack://ARFset/./node_modules/axios/lib/utils.js?");

/***/ }),

/***/ "./build/arfset_ES6_wasm.js":
/*!**********************************!*\
  !*** ./build/arfset_ES6_wasm.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("var __filename = \"/index.js\";\nvar __dirname = \"/\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\n\nvar arFset = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  if (true) _scriptDir = _scriptDir || __filename;\n  return function (arFset) {\n    arFset = arFset || {};\n    var Module = typeof arFset !== \"undefined\" ? arFset : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(window)) === \"object\";\n    ENVIRONMENT_IS_WORKER = typeof importScripts === \"function\";\n    ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(process)) === \"object\" && (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(process.versions) === \"object\" && typeof process.versions.node === \"string\";\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n    var scriptDirectory = \"\";\n\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n\n      return scriptDirectory + path;\n    }\n\n    var read_, readAsync, readBinary, setWindowTitle;\n    var nodeFS;\n    var nodePath;\n\n    if (ENVIRONMENT_IS_NODE) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = (__webpack_require__(/*! path */ \"?f955\").dirname)(scriptDirectory) + \"/\";\n      } else {\n        scriptDirectory = __dirname + \"/\";\n      }\n\n      read_ = function shell_read(filename, binary) {\n        var ret = tryParseAsDataURI(filename);\n\n        if (ret) {\n          return binary ? ret : ret.toString();\n        }\n\n        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"?4dea\");\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"?f955\");\n        filename = nodePath[\"normalize\"](filename);\n        return nodeFS[\"readFileSync\"](filename, binary ? null : \"utf8\");\n      };\n\n      readBinary = function readBinary(filename) {\n        var ret = read_(filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process[\"argv\"].length > 1) {\n        thisProgram = process[\"argv\"][1].replace(/\\\\/g, \"/\");\n      }\n\n      arguments_ = process[\"argv\"].slice(2);\n      process[\"on\"](\"uncaughtException\", function (ex) {\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      });\n      process[\"on\"](\"unhandledRejection\", abort);\n\n      quit_ = function quit_(status) {\n        process[\"exit\"](status);\n      };\n\n      Module[\"inspect\"] = function () {\n        return \"[Emscripten Module object]\";\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != \"undefined\") {\n        read_ = function shell_read(f) {\n          var data = tryParseAsDataURI(f);\n\n          if (data) {\n            return intArrayToString(data);\n          }\n\n          return read(f);\n        };\n      }\n\n      readBinary = function readBinary(f) {\n        var data;\n        data = tryParseAsDataURI(f);\n\n        if (data) {\n          return data;\n        }\n\n        if (typeof readbuffer === \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, \"binary\");\n        assert((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(data) === \"object\");\n        return data;\n      };\n\n      if (typeof scriptArgs != \"undefined\") {\n        arguments_ = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        arguments_ = arguments;\n      }\n\n      if (typeof quit === \"function\") {\n        quit_ = function quit_(status) {\n          quit(status);\n        };\n      }\n\n      if (typeof print !== \"undefined\") {\n        if (typeof console === \"undefined\") console = {};\n        console.log = print;\n        console.warn = console.error = typeof printErr !== \"undefined\" ? printErr : print;\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document !== \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf(\"/\") + 1);\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      {\n        read_ = function read_(url) {\n          try {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.send(null);\n            return xhr.responseText;\n          } catch (err) {\n            var data = tryParseAsDataURI(url);\n\n            if (data) {\n              return intArrayToString(data);\n            }\n\n            throw err;\n          }\n        };\n\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            try {\n              var xhr = new XMLHttpRequest();\n              xhr.open(\"GET\", url, false);\n              xhr.responseType = \"arraybuffer\";\n              xhr.send(null);\n              return new Uint8Array(xhr.response);\n            } catch (err) {\n              var data = tryParseAsDataURI(url);\n\n              if (data) {\n                return data;\n              }\n\n              throw err;\n            }\n          };\n        }\n\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n\n          xhr.onload = function () {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              onload(xhr.response);\n              return;\n            }\n\n            var data = tryParseAsDataURI(url);\n\n            if (data) {\n              onload(data.buffer);\n              return;\n            }\n\n            onerror();\n          };\n\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {}\n\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var STACK_ALIGN = 16;\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN;\n      return Math.ceil(size / factor) * factor;\n    }\n\n    var tempRet0 = 0;\n\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function getTempRet0() {\n      return tempRet0;\n    };\n\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(WebAssembly)) !== \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed: \" + text);\n      }\n    }\n\n    var UTF8Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n\n      while (heap[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n\n      if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n      } else {\n        var str = \"\";\n\n        while (idx < endPtr) {\n          var u0 = heap[idx++];\n\n          if (!(u0 & 128)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = heap[idx++] & 63;\n\n          if ((u0 & 224) == 192) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = heap[idx++] & 63;\n\n          if ((u0 & 240) == 224) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;\n          }\n\n          if (u0 < 65536) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 65536;\n            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n          }\n        }\n      }\n\n      return str;\n    }\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    }\n\n    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n        }\n\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | u >> 6;\n          heap[outIdx++] = 128 | u & 63;\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | u >> 12;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | u >> 18;\n          heap[outIdx++] = 128 | u >> 12 & 63;\n          heap[outIdx++] = 128 | u >> 6 & 63;\n          heap[outIdx++] = 128 | u & 63;\n        }\n      }\n\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;\n        if (u <= 127) ++len;else if (u <= 2047) len += 2;else if (u <= 65535) len += 3;else len += 4;\n      }\n\n      return len;\n    }\n\n    var UTF16Decoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n\n    function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n\n      while (!(idx >= maxIdx) && HEAPU16[idx]) {\n        ++idx;\n      }\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var str = \"\";\n\n        for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) break;\n          str += String.fromCharCode(codeUnit);\n        }\n\n        return str;\n      }\n    }\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n      var str = \"\";\n\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) break;\n        ++i;\n\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n\n      return str;\n    }\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n\n      return len;\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 268435456;\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [Module[\"preRun\"]];\n\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      runtimeInitialized = true;\n      if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function exitRuntime() {\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [Module[\"postRun\"]];\n\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      what += \"\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n\n    function isFileURI(filename) {\n      return filename.startsWith(\"file://\");\n    }\n\n    var wasmBinaryFile = \"data:application/octet-stream;base64,AGFzbQEAAAABmAImYAF/AGABfwF/YAJ/fwBgA39/fwF/YAV/f39/fwBgAn9/AX9gBH9/f38AYAN/f38AYAR/f39/AX9gBn9/f39/fwBgB39/f39/f38AYAV/f39/fwF/YAABf2AFf35+fn4AYAAAYAN/fn8BfmAGf39/f39/AX9gBH9+fn8AYAZ/fH9/f38Bf2AIf39/f39/f38AYAl/f39/f39/f38AYAp/f39/f39/f39/AGANf39/f39/f39/f39/fwBgA39/fgBgBH9/fn4AYAJ/fgBgA39+fwBgA39+fgBgAn98AGABfQF/YAd/f39/f39/AX9gAn5/AX9gA35+fgF/YAR+fn5+AX9gAX8BfmABfwF8YAJ+fgF8YAJ8fwF8AqcCMQFhAWEAAAFhAWIADAFhAWMABwFhAWQABAFhAWUAAAFhAWYAEwFhAWcAAgFhAWgAAgFhAWkABAFhAWoABwFhAWsACAFhAWwAAwFhAW0AAQFhAW4ABwFhAW8AAgFhAXAAFQFhAXEACQFhAXIADgFhAXMABQFhAXQAAwFhAXUABwFhAXYABgFhAXcACwFhAXgACgFhAXkAAQFhAXoABQFhAUEABQFhAUIACAFhAUMAAwFhAUQAAwFhAUUAAgFhAUYABAFhAUcAAgFhAUgABQFhAUkAAAFhAUoAAAFhAUsACQFhAUwAFgFhAU0AAAFhAU4AFAFhAU8ACQFhAVAAAAFhAVEACQFhAVIAAgFhAVMAAgFhAVQAAwFhAVUABwFhAVYAAQFhAVcACAPsAuoCAwAGAQENBQgIBQEDAwcRAQQNAgEFAQMAARscGQEBCwEBAQMFAAABBSEFAwIRAwEfBx0FBQAIBQEHAAwEAQUGCQUFAgUAAwYCIwUJBwYHAQ0gHgMIGgEHBQEDAgIBAg4BAAAAAggFAgIBAgECBQEAAAMCBwIAAAEYAw0CBQYHAwEOCCQNBRciEQ0HAQYLJQUBAQEFAAAAAAAADgACAAEBDAEBAQACBgEAAAUAAAIAAgAAAQICCAMFBgcBAQMHBwIMAAELAAwMBwkJCQQEBAUDBgYGAwMAAAECAAMDDA8BAhIDDwMDAwcBBQEMAQEFBQUFBQUACAgQEAALCwAAAAYGBgIFBQEFAAAFBQUFBQAFAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE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gICAgMD//wBUIA5CgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhCgwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEKIAMhAQwCCyABIA5CgICAgICAwP//AIWEUARAIAIgA4RQBEBCgICAgICA4P//ACEKQgAhAQwDCyAKQoCAgICAgMD//wCEIQpCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEAgASAOhCECQgAhASACUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASAOhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgDkL///////8/WARAIAVB0ABqIAEgCyABIAsgC1AiBht5IAZBBnStfKciBkEPaxA/IAUpA1giC0IghiAFKQNQIgFCIIiEIQ8gC0IgiCERQRAgBmshBgsgBiACQv///////z9WDQAaIAVBQGsgAyANIAMgDSANUCIIG3kgCEEGdK18pyIIQQ9rED8gBSkDSCICQg+GIAUpA0AiA0IxiIQhECACQi+GIANCEYiEIQwgAkIRiCESIAYgCGtBEGoLIQYgDEL/////D4MiAiABQv////8PgyIBfiITIANCD4ZCgID+/w+DIgMgD0L/////D4MiDn58IgRCIIYiDSABIAN+fCIMIA1UrSACIA5+IhUgAyALQv////8PgyILfnwiFCAQQv////8PgyINIAF+fCIQIAQgE1StQiCGIARCIIiEfCITIAIgC34iFiADIBFCgIAEhCIPfnwiAyANIA5+fCIRIAEgEkL/////B4NCgICAgAiEIgF+fCISQiCGfCIXfCEEIAcgCWogBmpB//8AayEGAkAgCyANfiIYIAIgD358IgIgGFStIAIgAiABIA5+fCICVq18IAIgAiAUIBVUrSAQIBRUrXx8IgJWrXwgASAPfnwgASALfiILIA0gD358IgEgC1StQiCGIAFCIIiEfCACIAFCIIZ8IgEgAlStfCABIAEgESASVq0gAyAWVK0gAyARVq18fEIghiASQiCIhHwiAVatfCABIBAgE1atIBMgF1atfHwiAiABVK18IgFCgICAgICAwACDUEUEQCAGQQFqIQYMAQsgDEI/iCEDIAFCAYYgAkI/iIQh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gAIQPiACQYACayICQf8BSw0ACwsgACAFIAIQPgsgBUGAAmokAAvLCQIEfwR+IwBB8ABrIgUkACAEQv///////////wCDIQoCQAJAIAFCAX0iC0J/USACQv///////////wCDIgkgASALVq18QgF9IgtC////////v///AFYgC0L///////+///8AURtFBEAgA0IBfSILQn9SIAogAyALVq18QgF9IgtC////////v///AFQgC0L///////+///8AURsNAQsgAVAgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCUKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACACIAEgA4UgAiAEhUKAgICAgICAgIB/hYRQIgYbIQRCACABIAYbIQMMAgsgAyAKQoCAgICAgMD//wCFhFANASABIAmEUARAIAMgCoRCAFINAiABIAODIQMgAiAEgyEEDAILIAMgCoRQRQ0AIAEhAyACIQQMAQsgAyABIAEgA1QgCSAKVCAJIApRGyIHGyEKIAQgAiAHGyILQv///////z+DIQkgAiAEIAcbIgJCMIinQf//AXEhCCALQjCIp0H//wFxIgZFBEAgBUHgAGogCiAJIAogCSAJUCIGG3kgBkEGdK18pyIGQQ9rED8gBSkDaCEJIAUpA2AhCkEQIAZrIQYLIAEgAyAHGyEDIAJC////////P4MhBCAIRQRAIAVB0ABqIAMgBCADIAQgBFAiBxt5IAdBBnStfKciB0EPaxA/QRAgB2shCCAFKQNYIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEEIAlCA4YgCkI9iIQhCSACIAuFIQwCfiADQgOGIgEgBiAIayIHRQ0AGiAHQf8ASwRAQgAhBEIBDAELIAVBQGsgASAEQYABIAdrED8gBUEwaiABIAQgBxBdIAUpAzghBCAFKQMwIAUpA0AgBSkDSIRCAFKthAshAiAJQoCAgICAgIAEhCEJIApCA4YhAwJAIAxCf1cEQCADIAJ9IgEgCSAEfSACIANWrX0iBIRQBEBCACEDQgAhBAwDCyAEQv////////8DVg0BIAVBIGogASAEIAEgBCAEUCIHG3kgB0EGdK18p0EMayIHED8gBiAHayEGIAUpAyghBCAFKQMgIQEMAQsgAiADfCIBIAJUrSAEIAl8fCIEQoCAgICAgIAIg1ANACABQgGDIARCP4YgAUIBiISEIQEgBkEBaiEGIARCAYghBAsgC0KAgICAgICAgIB/gyECIAZB//8BTgRAIAJCgICAgICAwP//AIQhBEIAIQMMAQsgBkEBTgR+IAatBSAFQRBqIAEgBCAGQf8AahA/IAUgASAEQQEgBmsQXSAFKQMAIAUpAxAgBSkDGIRCAFKthCEBIAUpAwghBEIACyEKIAGnQQdxIgZBBEutIARCPYYgAUIDiIQiAXwiAyABVK0gBEIDiEL///////8/gyAKQjCGhCAChHwhBAJAIAZBBEYEQCAEIANCAYMiASADfCIDIAFUrXwhBAwBCyAGRQ0BCwsgACADNwMAIAAgBDcDCCAFQfAAaiQAC34CAn8BfiMAQRBrIgMkACAAAn4gAUUEQEIADAELIAMgASABQR91IgJqIAJzIgKtQgAgAmciAkHRAGoQPyADKQMIQoCAgICAgMAAhUGegAEgAmutQjCGfCABQYCAgIB4ca1CIIaEIQQgAykDAAs3AwAgACAENwMIIANBEGokAAt/AQN/IAAhAQJAIABBA3EEQANAIAEtAABFDQIgAUEBaiIBQQNxDQALCwNAIAEiAkEEaiEBIAIoAgAiA0F/cyADQYGChAhrcUGAgYKEeHFFDQALIANB/wFxRQRAIAIgAGsPCwNAIAItAAEhAyACQQFqIgEhAiADDQALCyABIABrC6MCAQR/IwBBQGoiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhBSACQQA2AhQgAkGg8QE2AhAgAiAANgIMIAIgATYCCEEAIQMgAkEYakEAQScQMRogACAFaiEAAkAgBCABQQAQPQRAIAJBATYCOCAEIAJBCGogACAAQQFBACAEKAIAKAIUEQkAIABBACACKAIgQQFGGyEDDAELIAQgAkEIaiAAQQFBACAEKAIAKAIYEQQAAkACQCACKAIsDgIAAQILIAIoAhxBACACKAIoQQFGG0EAIAIoAiRBAUYbQQAgAigCMEEBRhshAwwBCyACKAIgQQFHBEAgAigCMA0BIAIoAiRBAUcNASACKAIoQQFHDQELIAIoAhghAwsgAkFAayQAIAMLMwEBfyAAQQEgABshAAJAA0AgABA0IgENAUHwhgIoAgAiAQRAIAERDgAMAQsLEBEACyABC0EBAn8CQCACRQ0AA0AgASADQQN0aigCACIERQ0BIAAgBEYEQCABIANBA3RqKAIEDwsgA0EBaiIDIAJHDQALC0EAC4oBAQR/IAAoAkxBAE4hAyAAKAIAQQFxIgRFBEAgACgCNCIBBEAgASAAKAI4NgI4CyAAKAI4IgIEQCACIAE2AjQLIABBzIYCKAIARgRAQcyGAiACNgIACwsgABDCARogACAAKAIMEQEAGiAAKAJgIgEEQCABEDILAkAgBEUEQCAAEDIMAQsgA0UNAAsLDwBByP0BKAIAIABBAnRqC2kBA34gACACQiCIIgMgAUIgiCIEfiACQv////8PgyICIAFC/////w+DIgF+IgVCIIggAiAEfnwiAkIgiHwgASADfiACQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAv5AQIDfgJ/IwBBEGsiBSQAAn4gAb0iA0L///////////8AgyICQoCAgICAgIAIfUL/////////7/8AWARAIAJCPIYhBCACQgSIQoCAgICAgICAPHwMAQsgAkKAgICAgICA+P8AWgRAIANCPIYhBCADQgSIQoCAgICAgMD//wCEDAELIAJQBEBCAAwBCyAFIAJCACADp2dBIGogAkIgiKdnIAJCgICAgBBUGyIGQTFqED8gBSkDACEEIAUpAwhCgICAgICAwACFQYz4ACAGa61CMIaECyECIAAgBDcDACAAIAIgA0KAgICAgICAgIB/g4Q3AwggBUEQaiQACz8CAn8BfiAAIAE3A3AgACAAKAIIIgIgACgCBCIDa6wiBDcDeCAAIAMgAadqIAIgASAEUxsgAiABQgBSGzYCaAsHACAAQQxqCxIAIAAQOygCACAAKAIAa0EDdQv0AQECfyACIARIBEAgACABIAIgBBA5RQRAQX8PCyAAKAIMIQIgACgCCCEBCyAEQQJ0IgZBkMIBaigCACABIAIgBGsiAnVxIgUgAyAGaigCAEoEQANAIAJBAEwEQCAAIAEgAkEBEDlFBEBBfw8LIAAoAgwhAiAAKAIIIQELIAEgAkEBayICdkEBcSAFQQF0ciIFIAMgBEEBaiIEQQJ0aigCAEoNAAsLIAAgAjYCDCAAIAE2AgggBEERTgRAIAAoAhAiACgCACIBQfkANgIUIABBfyABKAIEEQIAQQAPCyADKAKMASADIARBAnRqKAJIIAVqai0AEQsHACAAQQRqCxQBAX9BBBBGIgEgACgCADYCACABCwoAIABBMGtBCkkLRwEBfyMAQRBrIgMkACADIAI2AgxBpP4AIAFB4PQBQbn/AEETIANBDGoQUUHg9AFBvf8AQRQgA0EMahBREA8gA0EQaiQAIAALKAEBfyABIAFBAWsiAnFFBEAgACACcQ8LIAAgAU8EfyAAIAFwBSAACwsDAAELBgAgABAyC1IBAn9BzPsBKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQGEUNAQtBzPsBIAA2AgAgAQ8LQeT9AUEwNgIAQX8LKQAgAEEIdEGAgPwHcSAAQRh0ciAAQQh2QYD+A3EgAEEYdnJyIAAgARsL2wECAX8CfkEBIQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAsaACAAIAEQmAIiAEEAIAAtAAAgAUH/AXFGGwv5AgEGfyAAKAIEIQYgAkHxk+vcA08EQCAAKAIAQriAgIAQNwIUIAAgACgCACgCABEAAAtBCCACQQdxIgNrQQAgAxshAyABQQJPBEAgACgCACIFIAE2AhggBUEPNgIUIAAgACgCACgCABEAAAsgAiADaiEDAkAgBiABQQJ0aiIIKAI0IgIEQANAIAMgAiIEKAIITQRAIAQhAQwDCyAEKAIAIgINAAsLQfCT69wDIANrIgIgAUECdEGEwwFB/MIBIAQbaigCACIBIAEgAksbIgIgA2oiBUEQaiIHEDQiAUUEQANAIAJB4wBNBEAgACgCAEK4gICAIDcCFCAAIAAoAgAoAgARAAALIAJBAXYiASECIAEgA2oiBUEQaiIHEDQiAUUNAAsLIAYgBigCTCAHajYCTCABIAU2AgggAUIANwMAIARFBEAgCCABNgI0DAELIAQgATYCAAsgASABKAIEIgAgA2o2AgQgASABKAIIIANrNgIIIAAgAWpBEGoLYwIBfwF+IwBBEGsiAiQAIAACfiABRQRAQgAMAQsgAiABrUIAIAFnIgFB0QBqED8gAikDCEKAgICAgIDAAIVBnoABIAFrrUIwhnwhAyACKQMACzcDACAAIAM3AwggAkEQaiQAC1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC7RUAxx/CH4BfCMAQRBrIhwkACAcIAI2AgwjAEGQAWsiBiQAIAZBAEGQARAxIhlBfzYCTCAZIAA2AiwgGUG5ATYCICAZIAA2AlQgAiEXIwBBsAJrIgkkACAZIgMoAkwaAkAgAS0AACICRQ0AAkACQAJAAkADQAJAAkAgAkH/AXEQXwRAA0AgASICQQFqIQEgAi0AARBfDQALIANCABBMA0ACfyADKAIEIgAgAygCaEkEQCADIABBAWo2AgQgAC0AAAwBCyADEDULEF8NAAsgAygCBCEBIAMoAmgEQCADIAFBAWsiATYCBAsgASADKAIIa6wgAykDeCAlfHwhJQwBCwJ/AkACQCABLQAAIgJBJUYEQCABLQABIgBBKkYNASAAQSVHDQILIANCABBMIAEgAkElRmohAgJ/IAMoAgQiACADKAJoSQRAIAMgAEEBajYCBCAALQAADAELIAMQNQsiACACLQAARwRAIAMoAmgEQCADIAMoAgRBAWs2AgQLIABBf0oNC0EAIRQgGA0LDAkLICVCAXwhJQwDC0EAIQwgAUECagwBCwJAIAAQUkUNACABLQACQSRHDQAgAS0AAUEwayEAIwBBEGsiAiAXNgIMIAIgAEECdCAXakEEayAXIABBAUsbIgBBBGo2AgggACgCACEMIAFBA2oMAQsgFygCACEMIBdBBGohFyABQQFqCyECQQAhFAJAIAItAAAQUkUEQEEAIQEMAQtBACEBA38gAkEBaiEAIAEgAi0AAGpBMGshASACLQABEFIEfyABQQpsIQEgACECDAEFIAALCyECCyACLQAAIgZB7QBHBH8g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gICAgICA/z8QNiAAQUBrICIgIyAAKQNQIAApA1gQQiAAKQNIISNBASEVIAApA0AhIgsgH0IBfCEfQQEhAQsgAygCBCIFIAMoAmhJBH8gAyAFQQFqNgIEIAUtAAAFIAMQNQshBQwBCwsCfgJAIAFFBEAgAygCaEUNASADIAMoAgRBAWs2AgQMAQsgH0IHVwRAIB8hIANAIAdBBHQhByAgQgF8IiBCCFINAAsLAkAgBUFfcUHQAEYEQCADELcBIiBCgICAgICAgICAf1INAUIAISIgA0IAEExCAAwDCyADKAJoBEAgAyADKAIEQQFrNgIEC0IAISALIAdFBEAgAEHwAGogBrdEAAAAAAAAAACiEEsgACkDcCEiIAApA3gMAgsgISAfIAQbQgKGICB8QiB9Ih9BACATa61VBEBB5P0BQcQANgIAIABBoAFqIAYQQyAAQZABaiAAKQOgASAAKQOoAUJ/Qv///////7///wAQNiAAQYABaiAAKQOQASAAKQOYAUJ/Qv///////7///wAQNiAAKQOAASEiIAApA4gBDAILIBNB4gFrrCAfVwRAIAdBf0oEQANAIABBoANqICIgI0IAQoCAgICAgMD/v38QQiAiICNCgICAgICAgP8/EIEBIQEgAEGQA2ogIiAjICIgACkDoAMgAUEASCIFGyAjIAApA6gDIAUbEEIgH0IBfSEfIAApA5gDISMgACkDkAMhIiAHQQF0IAFBf0pyIgdBf0oNAAsLAn4gHyATrH1CIHwiIKciAUEAIAFBAEobIBIgICASrVMbIgFB8QBOBEAgAEGAA2ogBhBDIAApA4gDISEgACkDgAMhJEIADAELIABB4AJqQZABIAFrEHkQSyAAQdACaiAGEEMgAEHwAmogACkD4AIgACkD6AIgACkD0AIiJCAAKQPYAiIhELkBIAApA/gCISYgACkD8AILISAgAEHAAmogByAHQQFxRSAiICNCAEIAEFlBAEcgAUEgSHFxIgFqEFwgAEGwAmogJCAhIAApA8ACIAApA8gCEDYgAEGQAmogACkDsAIgACkDuAIgICAmEEIgAEGgAmpCACAiIAEbQgAgIyABGyAkICEQNiAAQYACaiAAKQOgAiAAKQOoAiAAKQOQAiAAKQOYAhBCIABB8AFqIAApA4ACIAApA4gCICAgJhCAASAAKQPwASIgIAApA/gB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IABBF2xBBXZBB3FBseoBaiwAACEIIAFBsegBai0AACIGIABJBEADQCAFIAZyIgVB////P0sgAAJ/IAMoAgQiASADKAJoSQRAIAMgAUEBajYCBCABLQAADAELIAMQNQsiAUGx6AFqLQAAIgZNckUEQCAFIAh0IQUMAQsLIAWtIR8LIAAgBk0NAEJ/IAitIiCIIiEgH1QNAANAIAatQv8BgyAfICCGhCEfIAACfyADKAIEIgEgAygCaEkEQCADIAFBAWo2AgQgAS0AAAwBCyADEDULIgFBsegBai0AACIGTQ0BIB8gIVgNAAsLIAAgAUGx6AFqLQAATQ0AA0AgAAJ/IAMoAgQiASADKAJoSQRAIAMgAUEBajYCBCABLQAADAELIAMQNQtBsegBai0AAEsNAAtB5P0BQcQANgIAQQAhB0J/IR8LIAMoAmgEQCADIAMoAgRBAWs2AgQLIB9Cf1EEQCAHQQFyRQRAQeT9AUHEADYCAEJ+DAMLCyAfIAesIiCFICB9DAELIANCABBMQgALIR8gBEEQaiQAIAMpA3hCACADKAIEIAMoAghrrH1RDQsgDEUgEUHwAEdyRQRAIAwgHz4CAAwFCyAMIAogHxC2AQwECyMAQSBrIgAkAAJAIB9C////////////AIMiIUKAgICAgIDAwD99ICFCgICAgICAwL/AAH1UBEAgH0IZiKchBiAgUCAfQv///w+DIiFCgICACFQgIUKAgIAIURtFBEAgBkGBgICABGohAQwCCyAGQYCAgIAEaiEBICAgIUKAgIAIhYRCAFINASABIAZBAXFqIQEMAQsgIFAgIUKAgICAgIDA//8AVCAhQoCAgICAgMD//wBRG0UEQCAfQhmIp0H///8BcUGAgID+B3IhAQwBC0GAgID8ByEBICFC////////v7/AAFYNAEEAIQEgIUIwiKciBkGR/gBJDQAgAEEQaiAgIB9C////////P4NCgICAgICAwACEIiEgBkGB/gBrED8gACAgICFBgf8AIAZrEF0gACkDCCIgQhmIpyEBIAApAwAgACkDECAAKQMYhEIAUq2EIiFQICBC////D4MiIEKAgIAIVCAgQoCAgAhRG0UEQCABQQFqIQEMAQsgISAgQoCAgAiFhEIAUg0AIAFBAXEgAWohAQsgAEEgaiQAIAwgASAfQiCIp0GAgICAeHFyvjgCAAwDCyAMICAgHxCzATkDAAwCCyAMICA3AwAgDCAfNwMIDAELIAFBAWpBHyARQeMARiIPGyEHAkAgCkEBRyISRQRAIAwhACAUBEAgB0ECdBA0IgBFDQcLIAlCADcDqAJBACEBA0AgACEQAkADQAJ/IAMoAgQiACADKAJoSQRAIAMgAEEBajYCBCAALQAADAELIAMQNQsiACAJai0AIUUNASAJIAA6ABsgCUEcaiEFQQAhBiMAQRBrIg0kACAJQagCaiIAQcCGAiAAGyIKKAIAIQACQAJAAkAgCUEbaiILRQRAIAANAQwDC0F+IQYgBSANQQxqIAUbIQQCQCAABEBBASEFDAELIAstAAAiAEEYdEEYdSIFQQBOBEAgBCAANgIAIAVBAEchBgwECyALLAAAIQBBlPsBKAIAKAIARQRAIAQgAEH/vwNxNgIAQQEhBgwECyAAQf8BcUHCAWsiAEEySw0BIABBAnRBwOoBaigCACEAQQAiBUUNAiALQQFqIQsLIAstAAAiCEEDdiITQRBrIABBGnUgE2pyQQdLDQADQCAFQQFrIQUgCEGAAWsgAEEGdHIiAEEATgRAIApBADYCACAEIAA2AgBBASAFayEGDAQLIAVFDQIgC0EBaiILLQAAIghBwAFxQYABRg0ACwsgCkEANgIAQeT9AUEZNgIAQX8hBgwBCyAKIAA2AgALIA1BEGokACAGQX5GDQAgBkF/Rg0HIBAEQCAQIAFBAnRqIAkoAhw2AgAgAUEBaiEBCyAUIAEgB0ZxRQ0ACyAQIAdBAXRBAXIiB0ECdBB6IgANAQwGCwsgCUGoAmoEfyAJKAKoAgVBAAsNBEEAIQsMAQsgFARAQQAhASAHEDQiAEUNBgNAIAAhCwNAAn8gAygCBCIAIAMoAmhJBEAgAyAAQQFqNgIEIAAtAAAMAQsgAxA1CyIAIAlqLQAhRQRAQQAhEAwECyABIAtqIAA6AAAgAUEBaiIBIAdHDQALQQAhECALIAdBAXRBAXIiBxB6IgANAAsMBwtBACEBIAwEQANAAn8gAygCBCIAIAMoAmhJBEAgAyAAQQFqNgIEIAAtAAAMAQsgAxA1CyIAIAlqLQAhBEAgASAMaiAAOgAAIAFBAWohAQwBBUEAIRAgDCELDAMLAAsACwNAAn8gAygCBCIAIAMoAmhJBEAgAyAAQQFqNgIEIAAtAAAMAQsgAxA1CyAJai0AIQ0AC0EAIQtBACEQCyADKAIEIQAgAygCaARAIAMgAEEBayIANgIECyADKQN4IAAgAygCCGusfCIgUCARQeMARkEAIB8gIFIbcg0HAkAgFEUNACASRQRAIAwgEDYCAAwBCyAMIAs2AgALIA8NACAQBEAgECABQQJ0akEANgIACyALRQRAQQAhCwwBCyABIAtqQQA6AAALIAMoAgQgAygCCGusIAMpA3ggJXx8ISUgGCAMQQBHaiEYCyACQQFqIQEgAi0AASICDQEMBgsLQQAhCwwBC0EAIQtBACEQCyAYDQELQX8hGAsgFEUNACALEDIgEBAyCyAJQbACaiQAIBghACAZQZABaiQAIBxBEGokACAACxAAIABBIEYgAEEJa0EFSXILgwECA38BfgJAIABCgICAgBBUBEAgACEFDAELA0AgAUEBayIBIAAgAEIKgCIFQgp+fadBMHI6AAAgAEL/////nwFWIQIgBSEAIAINAAsLIAWnIgIEQANAIAFBAWsiASACIAJBCm4iA0EKbGtBMHI6AAAgAkEJSyEEIAMhAiAEDQALCyABC6EBAQN/IwBBEGsiBSQAIAUgAjYCDCMAQaABayIDJAAgA0EIakGY4gFBkAEQPBogAyAANgI0IAMgADYCHCADQX4gAGsiBEH/////ByAEQf////8HSRsiBDYCOCADIAAgBGoiADYCJCADIAA2AhggA0EIaiABIAIQugEgBARAIAMoAhwiACAAIAMoAhhGa0EAOgAACyADQaABaiQAIAVBEGokAAulAQIBfQJ/An8gALwiAkEXdkH/AXEiA0GVAU0EQCADQf0ATQR9IABDAAAAAJQFAn0gACAAjCACQX9KGyIAQwAAAEuSQwAAAMuSIACTIgFDAAAAP14EQCAAIAGSQwAAgL+SDAELIAAgAZIiACABQwAAAL9fRQ0AGiAAQwAAgD+SCyIAIACMIAJBf0obCyEACyAAi0MAAABPXQsEQCAAqA8LQYCAgIB4CwsAIAAgATYCACAAC64CAQV/A0ACf0EAIQIgASgCTBpB/wEhAiAAIQMCQANAAn8gASgCBCIEQQogASgCCCAEaxCDASIGBEAgBiABKAIEIgRrQQFqDAELIAEoAgggASgCBCIEawshBSADIAQgBSACIAIgBUsbIgQQPBogASABKAIEIARqIgU2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QCABKAIEIgcgASgCACIGSgRAIAYhCgNAIAIgCUwEQCANIApBAnRqKAIAIQwgAiEDA0AgBSALTARAIAwgA0EGdGogBUEBdGohACAFIQQDQCAALwEABEAgASAKNgIADAcLIABBAmohACAEIAtHIQggBEEBaiEEIAgNAAsLIAMgCUchACADQQFqIQMgAA0ACwsgByAKRyEAIApBAWohCiAADQALCyAGIQoLAkAgByAKSgRAIAchCANAIAIgCUwEQCANIAhBAnRqKAIAIQwgAiEDA0AgBSALTARAIAwgA0EGdGogBUEBdGohACAFIQQDQCAALwEABEAgASAINgIEDAcLIABBAmohACAEIAtHIQYgBEEBaiEEIAYNAAsLIAMgCUchACADQQFqIQMgAA0ACwsgCCAKSiEAIAhBAWshCCAADQALCyAHIQgLAkAgAiAJSARAIAIhBgNAIAggCiIDTgRAA0AgBSALTARAIA0gA0ECdGooAgAgBkEGdGogBUEBdGohACAFIQQDQCAALwEABEAgASAGNgIIDAcLIABBAmohACAEIAtHIQcgBEEBaiEEIAcNAAsLIAMgCEchACADQQFqIQMgAA0ACwsgBiAJRyEAIAZBAWohBiAADQALCyACIQYLAkAgBiAJSARAIAkhBwNAIAggCiIDTgRAA0AgBSALTARAIA0gA0ECdGooAgAgB0EGdGogBUEBdGohACAFIQQDQCAALwEABEAgASAHNgIMDAcLIABBAmohACAEIAtHIQIgBEEBaiEEIAINAAsLIAMgCEchACADQQFqIQMgAA0ACwsgBiAHSCEAIAdBAWshByAADQALCyAJIQcLAkAgBSALSARAIAZBBnQhDCAFIQMDQCAIIAoiAk4EQANAIAYgB0wEQCANIAJBAnRqKAIAIAxqIANBAXRqIQAgBiEEA0AgAC8BAARAIAEgAzYCEAwHCyAAQUBrIQAgBCAHRyEJIARBAWohBCAJDQALCyACIAhHIQAgAkEBaiECIAANAAsLIAMgC0chACADQQFqIQMgAA0ACwsgBSEDCwJAIAMgC0gEQCAGQQZ0IQwgCyEFA0AgCCAKIgJOBEADQCAGIAdMBEAgDSACQQJ0aigCACAMaiAFQQF0aiEAIAYhBANAIAAvAQAEQCABIAU2AhQMBwsgAEFAayEAIAQgB0chCSAEQQFqIQQgCQ0ACwsgAiAIRyEAIAJBAWohAiAADQALCyADIAVIIQAgBUEBayEFIAANAAsLIAshBQsgASAHIAZrQQxsIgAgAGwgCCAKa0EEdCIAIABsaiAFIANrIg5BA3QiACAAbGo2AhhBACEEIAggCk4EQCAOQQFqQQNxIQsDQCAGIAdMBEAgDSAKQQJ0aigCACEPIAYhAgNAIAIhDAJAIAMgBUoNACAPIAxBBnRqIANBAXRqIQIgAyEAIAshCSALBEADQCAAQQFqIQAgBCACLwEAQQBHaiEEIAJBAmohAiAJQQFrIgkNAAsLIA5BA0kNAANAIAQgAi8BAEEAR2ogAi8BAkEAR2ogAi8BBEEAR2ogAi8BBkEAR2ohBCACQQhqIQIgAEEDaiEJIABBBGohACAFIAlHDQALCyAMQQFqIQIgByAMRw0ACwsgCCAKRyEAIApBAWohCiAADQALCyABIAQ2AhwLiQMBBn8gACgCGCIBKAIEIQIgASgCACEEA0AgAkUEQCAAIAEoAgwRAQBFBEBBAA8LIAEoAgAhBCABKAIEIQILIARBAWohAyACQQFrIQIgBC0AAEH/AUcEQANAIAAoAtADIgQgBCgCGEEBajYCGCABIAI2AgQgASADNgIAIAIEfyACBSAAIAEoAgwRAQBFBEBBAA8LIAEoAgAhAyABKAIEC0EBayECIAMtAAAhBCADQQFqIQMgBEH/AUcNAAsLA0AgAgR/IAIFIAAgASgCDBEBAEUEQEEADwsgASgCACEDIAEoAgQLQQFrIQIgAy0AACEFIANBAWoiBCEDIAVB/wFGDQALIAVFBEAgACgC0AMiAyADKAIYQQJqNgIYIAEgAjYCBCABIAQ2AgAMAQsLIAAoAtADKAIYIgMEQCAAKAIAIgYgAzYCGCAGQfcANgIUIAAoAgAgBTYCHCAAQX8gACgCACgCBBECACAAKALQA0EANgIYCyAAIAU2ArgDIAEgAjYCBCABIAQ2AgBBAQsMACAAIAEoAgA2AgALiAgBA38jAEEQayIAJAACQCAAQQxqIABBCGoQGg0AQdCGAiAAKAIMQQJ0QQRqEDQiAjYCACACRQ0AIAAoAggQNCICBEBB0IYCKAIAIAAoAgxBAnRqQQA2AgBB0IYCKAIAIAIQGUUNAQtB0IYCQQA2AgALIABBEGokACMAQRBrIgAkACMAQRBrIgEkACABQQA2AgxByP0BIAFBDGoQjgEjAEEQayICJAAgAkEANgIMQcz9ASACQQxqIAJBCGoQowEgAkEQaiQAIAFBEGokAEHQ/QFBADYCACAAQQA2AgxB1P0BIABBDGogAEEIahCjASAAQYCAgPwDNgIEQdj9ASAAKgIEOAIAIABBEGokACMAQRBrIgIkACMAQRBrIgAkAEGl/ABBA0H4/QBBhP4AQQ9BDRAQIABBEGokACMAQRBrIgAkAEGr/ABBA0GM/gBBhP4AQRBBDhAQIABBEGokAAJ/An9BpP4AQbr8AEG0/wBBEUG2/wBBEhAqIAJBCGoLQcT8AEEAEFNByvwAQQQQU0HR/ABBCBBTQdX8AEEMEFNB3vwAQRAQU0Hp/ABBFBBTQfP8AEEYEFMhASMAQRBrIgAkACAAQRw2AgxBpP4AQYT9AEHsgAFBuf8AQRUgAEEMahBRQeyAAUG9/wBBFiAAQQxqEFEQDyAAQRBqJAAgAQtBjv0AQSgQUxpBpP4AECkCf0GQgQFBlv0AQbT/AEEXQbb/AEEYECggAgtBABDDAUEEEMMBGkGQgQEQJiMAQSBrIgAkAEHsgAFB6IEBQaiCAUEAQbiCAUEbQbuCAUEAQbuCAUEAQZ/9AEG2/wBBHBAlIwBBEGsiASQAQeyAAUEBQcCCAUG4ggFBI0EdECQgAUEQaiQAIABBADYCHCAAQR42AhggACAAKQMYNwMQIwBBEGsiASQAIAEgACkCEDcDCEHsgAFBmIEBQQNBxIIBQb3/AEEkIAFBCGoQaEEAEAUgAUEQaiQAIABBADYCHCAAQR82AhggACAAKQMYNwMIIwBBEGsiASQAIAEgACkCCDcDCEHsgAFBooEBQQRB0IIBQeCCAUElIAFBCGoQaEEAEAUgAUEQaiQAIABBADYCHCAAQSA2AhggACAAKQMYNwMAIwBBEGsiASQAIAEgACkCADcDCEHsgAFBqYEBQQJB6IIBQbn/AEEmIAFBCGoQaEEAEAUgAUEQaiQAIwBBEGsiASQAIAFBITYCDEHsgAFBroEBQQNB8IIBQYT+AEEnIAFBDGoQUUEAEAUgAUEQaiQAIwBBEGsiASQAIAFBIjYCDEHsgAFBsoEBQQRBoIMBQbCDAUEoIAFBDGoQUUEAEAUgAUEQaiQAIABBIGokACACQRBqJABB4f0BQa8BEQEAGgtNACAAQgA3AmggAEEuNgIQIABBLzYCDCAAQTA2AgggAEExNgIEIABBMjYCACAAQgA3AnwgAEL+ADcCdCAAQZCoATYCcCAAQQA2AhQgAAsmAQF/IAAoAgQiAQRAIAAgASgCKBEAAAsgAEEANgIUIABBADYCBAs7AQF/IAAoAgQiAQRAIABBASABKAIkEQIAIAAoAhAEQCAAQQA2ArgCIABByAE2AhQPCyAAQeQANgIUCwtVAQF/IAAoAgQhAQNAIAEgACgCCEcEQCAAKAIQGiAAIAAoAghBCGs2AggMAQsLIAAoAgAEQCAAKAIQGiAAKAIAIQEgABBNKAIAIAAoAgBrGiABEDILC3EBBH8gABCmASAAEDsaIAFBBGoiAyICIAIoAgAgACgCBCAAKAIAIgRrIgJrIgU2AgAgAkEBTgRAIAUgBCACEDwaCyAAIAMQcyAAQQRqIAFBCGoQcyAAEDsgARBNEHMgASABKAIENgIAIAAgABBAEJoBC3MBA38jAEEQayIEJAAgBEEANgIMIABBDGoiBiAEQQxqEHggBkEEaiADENUBIAEEQCAAKAIQGiABEJkBIQULIAAgBTYCACAAIAUgAkEDdGoiAjYCCCAAIAI2AgQgABBNIAUgAUEDdGo2AgAgBEEQaiQAIAALDQAgACgCACABQQN0agsqACAAKAIAGiAAKAIAIAAQTkEDdGoaIAAoAgAaIAAoAgAgABBAQQN0ahoLGAEBfyAAEEAhAiAAIAEQpAEgACACEJcBCxwAIABB/////wFLBEBBsf0AEGoACyAAQQN0EEYLKgAgACgCABogACgCACAAEE5BA3RqGiAAKAIAIAAQTkEDdGoaIAAoAgAaC18BBH8jAEEQayIBJAAgABA7GiABQf////8BNgIMIAFB/////wc2AggjAEEQayIAJAAgAUEIaiICIAFBDGoiAxBxIQQgAEEQaiQAIAIgAyAEGygCACEAIAFBEGokACAAC0EBAX8gABCbASABSQRAELEBAAsgABA7GiAAIAEQmQEiAjYCACAAIAI2AgQgABA7IAIgAUEDdGo2AgAgAEEAEJoBCy4AIwBBEGsiASQAIABCADcCACABQQA2AgwgAEEIaiABQQxqEHggAUEQaiQAIAALCgAgAC0AC0EHdgsmAQF/Qcj9ASgCACEBQcj9ASAANgIAIAEEQEHI/QEQUCABEKIBCwutAgEHf0HI/QEQUBoCQCAABEACfyAAIgJB/////wNLBEBBsf0AEGoACyACQQJ0EEYLEJ8BQcj9ARBQIAI2AgADQCABIAJGBEBB0P0BKAIAIgNFDQMgAygCBCACEFQiBhBJQdD9ATYCAANAIAMoAgAiAEUNBAJAIAAoAgQgAhBUIgQgBkYNACAAIQEgBBBJKAIARQRAIAQQSSADNgIAIAQhBgwBCwNAAkAgASIFKAIARQRAQQAhAQwBCyAAQQhqIAUoAgBBCGoQ2gEhByAFKAIAIQEgBw0BCwsgAyABNgIAIAUgBBBJKAIAKAIANgIAIAQQSSgCACAANgIADAELIAAhAwwACwAFIAEQSUEANgIAIAFBAWohAQwBCwALAAtBABCfAUHI/QEQUEEANgIACwsJACABIAIQ2gELDAAgACgCABogARAyCwkAIAAgARCOAQsrAQF/IAAoAgQhAgNAIAEgAkcEQCAAEDsaIAJBCGshAgwBCwsgACABNgIECwwAIAAgACgCABCkAQsyACAAKAIAGiAAKAIAIAAQTkEDdGoaIAAoAgAgABBAQQN0ahogACgCACAAEE5BA3RqGgsEACAACxwAIAAgAUEIIAKnIAJCIIinIAOnIANCIIinEBcLkAIBA38CQCABIAIoAhAiBAR/IAQFQQAhBAJ/IAIgAi0ASiIDQQFrIANyOgBKIAIoAgAiA0EIcQRAIAIgA0EgcjYCAEF/DAELIAJCADcCBCACIAIoAiwiAzYCHCACIAM2AhQgAiADIAIoAjBqNgIQQQALDQEgAigCEAsgAigCFCIFa0sEQCACIAAgASACKAIkEQMADwsCfyACLABLQX9KBEAgASEEA0AgASAEIgNFDQIaIAAgA0EBayIEai0AAEEKRw0ACyACIAAgAyACKAIkEQMAIgQgA0kNAiAAIANqIQAgAigCFCEFIAEgA2sMAQsgAQshBCAFIAAgBBA8GiACIAIoAhQgBGo2AhQgASEECyAEC8oGAgR/A34jAEGAAWsiBSQAAkACQAJAIAMgBEIAQgAQWUUNAAJ/IARC////////P4MhCQJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAmEUBsMAgsgAyAJhFALC0UNACACQjCIpyIIQf//AXEiBkH//wFHDQELIAVBEGogASACIAMgBBA2IAUgBSkDECIBIAUpAxgiAiABIAIQtAEgBSkDCCECIAUpAwAhBAwBCyABIAJC////////P4MgBq1CMIaEIgogAyAEQv///////z+DIARCMIinQf//AXEiB61CMIaEIgkQWUEATARAIAEgCiADIAkQWQRAIAEhBAwCCyAFQfAAaiABIAJCAEIAEDYgBSkDeCECIAUpA3AhBAwBCyAGBH4gAQUgBUHgAGogASAKQgBCgICAgICAwLvAABA2IAUpA2giCkIwiKdB+ABrIQYgBSkDYAshBCAHRQRAIAVB0ABqIAMgCUIAQoCAgICAgMC7wAAQNiAFKQNYIglCMIinQfgAayEHIAUpA1AhAwsgCUL///////8/g0KAgICAgIDAAIQhCSAKQv///////z+DQoCAgICAgMAAhCEKIAYgB0oEQANAAn4gCiAJfSADIARWrX0iC0IAWQRAIAsgBCADfSIEhFAEQCAFQSBqIAEgAkIAQgAQNiAFKQMoIQIgBSkDICEEDAULIAtCAYYgBEI/iIQMAQsgCkIBhiAEQj+IhAshCiAEQgGGIQQgBkEBayIGIAdKDQALIAchBgsCQCAKIAl9IAMgBFatfSIJQgBTBEAgCiEJDAELIAkgBCADfSIEhEIAUg0AIAVBMGogASACQgBCABA2IAUpAzghAiAFKQMwIQQMAQsgCUL///////8/WARAA0AgBEI/iCEBIAZBAWshBiAEQgGGIQQgASAJQgGGhCIJQoCAgICAgMAAVA0ACwsgCEGAgAJxIQcgBkEATARAIAVBQGsgBCAJQv///////z+DIAZB+ABqIAdyrUIwhoRCAEKAgICAgIDAwz8QNiAFKQNIIQIgBSkDQCEEDAELIAlC////////P4MgBiAHcq1CMIaEIQILIAAgBDcDACAAIAI3AwggBUGAAWokAAuLDAEGfyAAIAFqIQUCQAJAIAAoAgQiAkEBcQ0AIAJBA3FFDQEgACgCACICIAFqIQECQCAAIAJrIgBBiIcCKAIARwRAIAJB/wFNBEAgACgCCCIEIAJBA3YiAkEDdEGchwJqRhogACgCDCIDIARHDQJB9IYCQfSGAigCAEF+IAJ3cTYCAAwDCyAAKAIYIQYCQCAAIAAoAgwiA0cEQCAAKAIIIgJBhIcCKAIASRogAiADNgIMIAMgAjYCCAwBCwJAIABBFGoiAigCACIEDQAgAEEQaiICKAIAIgQNAEEAIQMMAQsDQCACIQcgBCIDQRRqIgIoAgAiBA0AIANBEGohAiADKAIQIgQNAAsgB0EANgIACyAGRQ0CAkAgACAAKAIcIgRBAnRBpIkCaiICKAIARgRAIAIgAzYCACADDQFB+IYCQfiGAigCAEF+IAR3cTYCAAwECyAGQRBBFCAGKAIQIABGG2ogAzYCACADRQ0DCyADIAY2AhggACgCECICBEAgAyACNgIQIAIgAzYCGAsgACgCFCICRQ0CIAMgAjYCFCACIAM2AhgMAgsgBSgCBCICQQNxQQNHDQFB/IYCIAE2AgAgBSACQX5xNgIEIAAgAUEBcjYCBCAFIAE2AgAPCyAEIAM2AgwgAyAENgIICwJAIAUoAgQiAkECcUUEQCAFQYyHAigCAEYEQEGMhwIgADYCAEGAhwJBgIcCKAIAIAFqIgE2AgAgACABQQFyNgIEIABBiIcCKAIARw0DQfyGAkEANgIAQYiHAkEANgIADwsgBUGIhwIoAgBGBEBBiIcCIAA2AgBB/IYCQfyGAigCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPCyACQXhxIAFqIQECQCACQf8BTQRAIAUoAggiBCACQQN2IgJBA3RBnIcCakYaIAQgBSgCDCIDRgRAQfSGAkH0hgIoAgBBfiACd3E2AgAMAgsgBCADNgIMIAMgBDYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiA0cEQCAFKAIIIgJBhIcCKAIASRogAiADNgIMIAMgAjYCCAwBCwJAIAVBFGoiBCgCACICDQAgBUEQaiIEKAIAIgINAEEAIQMMAQsDQCAEIQcgAiIDQRRqIgQoAgAiAg0AIANBEGohBCADKAIQIgINAAsgB0EANgIACyAGRQ0AAkAgBSAFKAIcIgRBAnRBpIkCaiICKAIARgRAIAIgAzYCACADDQFB+IYCQfiGAigCAEF+IAR3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogAzYCACADRQ0BCyADIAY2AhggBSgCECICBEAgAyACNgIQIAIgAzYCGAsgBSgCFCICRQ0AIAMgAjYCFCACIAM2AhgLIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEGIhwIoAgBHDQFB/IYCIAE2AgAPCyAFIAJBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUH/AU0EQCABQQN2IgJBA3RBnIcCaiEBAn9B9IYCKAIAIgNBASACdCICcUUEQEH0hgIgAiADcjYCACABDAELIAEoAggLIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIDwtBHyECIABCADcCECABQf///wdNBEAgAUEIdiICIAJBgP4/akEQdkEIcSIEdCICIAJBgOAfakEQdkEEcSIDdCICIAJBgIAPakEQdkECcSICdEEPdiADIARyIAJyayICQQF0IAEgAkEVanZBAXFyQRxqIQILIAAgAjYCHCACQQJ0QaSJAmohBwJAAkBB+IYCKAIAIgRBASACdCIDcUUEQEH4hgIgAyAEcjYCACAHIAA2AgAgACAHNgIYDAELIAFBAEEZIAJBAXZrIAJBH0YbdCECIAcoAgAhAwNAIAMiBCgCBEF4cSABRg0CIAJBHXYhAyACQQF0IQIgBCADQQRxaiIHQRBqKAIAIgMNAAsgByAANgIQIAAgBDYCGAsgACAANgIMIAAgADYCCA8LIAQoAggiASAANgIMIAQgADYCCCAAQQA2AhggACAENgIMIAAgATYCCAsLTAEBfwJAIAFFDQAgAUGg8wEQRSIBRQ0AIAEoAgggACgCCEF/c3ENACAAKAIMIAEoAgxBABA9RQ0AIAAoAhAgASgCEEEAED0hAgsgAgtSAQF/IAAoAgQhBCAAKAIAIgAgAQJ/QQAgAkUNABogBEEIdSIBIARBAXFFDQAaIAIoAgAgAWooAgALIAJqIANBAiAEQQJxGyAAKAIAKAIcEQYACw8AIAEgACgCAGogAjYCAAt9AQN/IwBBEGsiBSQAIwBBEGsiAyQAIAEgAGtBAnUhAQNAIAEEQCADIAA2AgwgAyADKAIMIAFBAXYiBEECdGo2AgwgASAEQX9zaiAEIAMoAgwgAhBxIgQbIQEgAygCDEEEaiAAIAQbIQAMAQsLIANBEGokACAFQRBqJAAgAAvuDAEIfyMAQRBrIgQkACAEIAA2AgwCQCAAQdMBTQRAQaDsAUHg7QEgBEEMahCvASgCACEADAELIABBfE8EQBARAAsgBCAAIABB0gFuIgdB0gFsIgNrNgIIQeDtAUGg7wEgBEEIahCvAUHg7QFrQQJ1IQUCQANAIAVBAnRB4O0BaigCACADaiEAQQUhAyAGIQECQAJAA0AgASEGIANBL0YEQEHTASEDA0AgACADbiIBIANJDQQgACABIANsRg0DIAAgA0EKaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EMaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EQaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0ESaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EWaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EcaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EeaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EkaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EoaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EqaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0EuaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E0aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E6aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0E8aiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HCAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBxgBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQcgAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HOAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB0gBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQdgAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HgAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB5ABqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQeYAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HqAGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB7ABqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQfAAaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0H4AGoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANB/gBqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQYIBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GIAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBigFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQY4BaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GUAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBlgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQZwBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GiAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBpgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQagBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0GsAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBsgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQbQBaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0G6AWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBvgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQcABaiIBbiICIAFJDQQgACABIAJsRg0DIAAgA0HEAWoiAW4iAiABSQ0EIAAgASACbEYNAyAAIANBxgFqIgFuIgIgAUkNBCAAIAEgAmxGDQMgACADQdABaiIBbiICIAFJDQQgA0HSAWohAyAAIAEgAmxHDQALDAILIAAgA0ECdEGg7AFqKAIAIgFuIgIgAWwhCCABIAJLIgJFBEAgACAGIAIbIQEgA0EBaiEDIAAgCEcNAQsLIAIgACAIR3INAwtBACAFQQFqIgAgAEEwRiIAGyEFIAAgB2oiB0HSAWwhAwwBCwsgBCAANgIMDAELIAQgADYCDCAAIAYgAhshAAsgBEEQaiQAIAALCQBBjOwBEGoAC4sBAQN/QeSGAkHkhgIoAgBBAWoiBTYCACAAIAU2AgACQCADBEADQCACIARBA3RqIgYoAgBFDQIgBEEBaiIEIANHDQALCyAAIAEgAiADQQR0QQhyEHogA0EBdCIAELIBIQEgABAAIAEPCyAGIAU2AgAgAiAEQQN0aiIAIAE2AgQgAEEANgIIIAMQACACC9cDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIhUIAUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrED8gBCAAIAJBgfgAIAVrEF0gBCkDCEIEhiAEKQMAIgBCPIiEIQIgBCkDECAEKQMYhEIAUq0gAEL//////////w+DhCIAQoGAgICAgICACFoEQCACQgF8IQIMAQsgAEKAgICAgICAgAiFQgBSDQAgAkIBgyACfCECCyAEQSBqJAAgAiABQoCAgICAgICAgH+DhL8L+BACBX8LfiMAQcABayIFJAAgBEL///////8/gyESIAJC////////P4MhDCACIASFQoCAgICAgICAgH+DIREgBEIwiKdB//8BcSEHAkACQAJAIAJCMIinQf//AXEiCUEBa0H9/wFNBEAgB0EBa0H+/wFJDQELIAFQIAJC////////////AIMiCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIREMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhESADIQEMAgsgASAKQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIREMAwsgEUKAgICAgIDA//8AhCERQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAqEUA0CIAIgA4RQBEAgEUKAgICAgIDA//8AhCERQgAhAQwCCyAKQv///////z9YBEAgBUGwAWogASAMIAEgDCAMUCIGG3kgBkEGdK18pyIGQQ9rED9BECAGayEGIAUpA7gBIQwgBSkDsAEhAQsgAkL///////8/Vg0AIAVBoAFqIAMgEiADIBIgElAiCBt5IAhBBnStfKciCEEPaxA/IAYgCGpBEGshBiAFKQOoASESIAUpA6ABIQMLIAVBkAFqIBJCgICAgICAwACEIhRCD4YgA0IxiIQiAkKEyfnOv+a8gvUAIAJ9IgQQSiAFQYABakIAIAUpA5gBfSAEEEogBUHwAGogBSkDiAFCAYYgBSkDgAFCP4iEIgQgAhBKIAVB4ABqIARCACAFKQN4fRBKIAVB0ABqIAUpA2hCAYYgBSkDYEI/iIQiBCACEEogBUFAayAEQgAgBSkDWH0QSiAFQTBqIAUpA0hCAYYgBSkDQEI/iIQiBCACEEogBUEgaiAEQgAgBSkDOH0QSiAFQRBqIAUpAyhCAYYgBSkDIEI/iIQiBCACEEogBSAEQgAgBSkDGH0QSiAGIAkgB2tqIQYCfkIAIAUpAwhCAYYgBSkDAEI/iIRCAX0iCkL/////D4MiBCACQiCIIgt+Ig4gCkIgiCIKIAJC/////w+DIg9+fCICQiCIIAIgDlStQiCGhCAKIAt+fCACQiCGIgsgBCAPfnwiAiALVK0gAiACIAQgA0IRiEL/////D4MiDn4iDyAKIANCD4ZCgID+/w+DIg1+fCILQiCGIhAgBCANfnwgEFStIAogDn4gCyAPVK1CIIYgC0IgiIR8fHwiAlatfHwgAkIAUq18fSILQv////8PgyIOIAR+Ig8gCiAOfiINIAQgC0IgiCIQfnwiC0IghnwiDiAPVK0gCiAQfiALIA1UrUIghiALQiCIhHx8IA5CACACfSICQiCIIgsgBH4iDyACQv////8PgyINIAp+fCICQiCGIhAgBCANfnwgEFStIAogC34gAiAPVK1CIIYgAkIgiIR8fHwiAiAOVK18IAJCAn0iDyACVK18QgF9IgtC/////w+DIgIgDEIChiABQj6IhEL/////D4MiBH4iDiABQh6IQv////8PgyIKIAtCIIgiC358Ig0gDlStIA0gDSAPQiCIIg4gDEIeiEL//+//D4NCgIAQhCIMfnwiDVatfCALIAx+fCACIAx+IhMgBCALfnwiECATVK1CIIYgEEIgiIR8IA0gDSAQQiCGfCINVq18IA0gDSAKIA5+IhMgD0L/////D4MiDyAEfnwiECATVK0gECAQIAIgAUIChkL8////D4MiE358IhBWrXx8Ig1WrXwgDSALIBN+IgsgDCAPfnwiDCAEIA5+fCIEIAIgCn58IgJCIIggAiAEVK0gCyAMVq0gBCAMVK18fEIghoR8IgQgDVStfCAEIAQgECAOIBN+IgwgCiAPfnwiCkIgiCAKIAxUrUIghoR8IgogEFStIAogAkIghnwgClStfHwiBFatfCICQv////////8AWARAIAFCMYYgBEIgiCIBIANC/////w+DIgp+Ig0gBEL/////D4MiDCADQiCIIgt+fCIOQiCGIhAgCiAMfnwiDyAQVK19IA9CAFKtfSACQv////8PgyAKfiAMIBJC/////w+DfnwgASALfnwgDSAOVq1CIIYgDkIgiIR8IAQgFEIgiH4gAyACQiCIfnwgAiALfnwgASASfnxCIIZ8fSESIAZBAWshBkIAIA99DAELIARCIYghDCABQjCGIAJCP4YgBEIBiIQiBEL/////D4MiASADQiCIIgp+Ig8gDCACQh+GhCINQv////8PgyIQIANC/////w+DIgx+fCILQiCGIhMgASAMfnwiDiATVK19IA5CAFKtfSAEIBRCIIh+IAMgAkIhiH58IAJCAYgiAiAKfnwgDSASfnxCIIYgCiAQfiACQv////8PgyAMfnwgASASQv////8Pg358IAsgD1StQiCGIAtCIIiEfHx9IRJCACAOfQshASAGQYCAAU4EQCARQoCAgICAgMD//wCEIRFCACEBDAELIAZB//8AaiEHIAZBgYB/TARAAkAgBw0AIAQgAUIBhiADViASQgGGIAFCP4iEIgEgFFYgASAUURutfCIBIARUrSACQv///////z+DfCICQoCAgICAgMAAg1ANACACIBGEIREMAgtCACEBDAELIAQgAUIBhiADWiASQgGGIAFCP4iEIgEgFFogASAUURutfCIBIARUrSACQv///////z+DfCAHrUIwhnwgEYQhEQsgACABNwMAIAAgETcDCCAFQcABaiQADwsgAEIANwMAIABCgICAgICA4P//ACARIAIgA4RQGzcDCCAFQcABaiQACw0AIAEgACgCAGooAgALQwACQCAARQ0AAkACQAJAAkAgAUECag4GAAECAgQDBAsgACACPAAADwsgACACPQEADwsgACACPgIADwsgACACNwMACwv1AwIEfwF+AkACQAJAAn8gACgCBCIBIAAoAmhJBEAgACABQQFqNgIEIAEtAAAMAQsgABA1CyIBQStrDgMBAAEACyABQTBrIQIMAQsgAUEtRiEEAkACfyAAKAIEIgEgACgCaEkEQCAAIAFBAWo2AgQgAS0AAAwBCyAAEDULIgFBMGsiAkEK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AiAELQAGQQFqOwEEIAIgBC0AB0EBajsBBiABIAZqIABqIgIgBC0ACEEBajsBACACIAQtAAlBAWo7AQIgAiAELQAKQQFqOwEEIAIgBC0AC0EBajsBBiABIAhqIABqIgIgBC0ADEEBajsBACACIAQtAA1BAWo7AQIgAiAELQAOQQFqOwEEIAIgBC0AD0EBajsBBiABIAlqIABqIgIgBC0AEEEBajsBACACIAQtABFBAWo7AQIgAiAELQASQQFqOwEEIAIgBC0AE0EBajsBBiABIApqIABqIgIgBC0AFEEBajsBACACIAQtABVBAWo7AQIgAiAELQAWQQFqOwEEIAIgBC0AF0EBajsBBiABIAtqIABqIgIgBC0AGEEBajsBACACIAQtABlBAWo7AQIgAiAELQAaQQFqOwEEIAIgBC0AG0EBajsBBiABIA9qIABqIgEgBC0AHEEBajsBACABIAQtAB1BAWo7AQIgASAELQAeQQFqOwEEIAEgBC0AH0EBajsBBiAEQSBqIQQgB0EBaiIHQQRHDQALIA1BgAtqJAALEQAgACAAQQFrcUUgAEECS3ELywMBBH8gACgC5AMgAEEBQfwPIAAoAgQoAgARAwAiAEH8B2oiATYCKCAAQv////8PNwL4ByAAQoGAgIAgNwKACCAAQoOAgIDAADcCiAggAEL9////bzcC8AcgAEKFgICA4AA3ApAIIABC+////083AugHIABCh4CAgIABNwKYCCAAQvn///+vfzcC4AcgAEKJgICAoAE3AqAIIABC9////49/NwLYByAAQouAgIDAATcCqAggAEL1////7343AtAHIABCjYCAgOABNwKwCCAAQvP////PfjcCyAcgAEEPNgK4CCAAQvH///+vfjcCwAdBECECQRAhAwNAIAEgA0ECdCIAaiACNgIAIAEgAGtBACACayIENgIAIAEgAEEEcmogAjYCACABIANBf3NBAnRqIAQ2AgAgAkEBaiECQTAhACADQQJqIgNBMEcNAAsDQCABIABBAnQiAmpBIDYCACABIAJrQWA2AgAgASACQQRyakEgNgIAIAEgAEF/c0ECdGpBYDYCACABIAJBCHJqQSA2AgAgAUF+IABrQQJ0akFgNgIAIAEgAkEMcmpBIDYCACABQX0gAGtBAnRqQWA2AgAgAEEEaiIAQYACRw0ACwv3AgEKfyAA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IAAgB2otAAA6AAEgBCAAIAZqLQAAOgACIAQgCCAAQQFyIgtqLQAAOgADIAQgByALai0AADoABCAEIAYgC2otAAA6AAUgAEECaiEAIARBBmohBCAKQQJrIgoNAAsLIA1FDQAgBCAAIAhqLQAAOgAAIAQgACAHai0AADoAASAEIAAgBmotAAA6AAILIANBBGohAyACQQFqIQIgCUEBayEEIAlBAk4NAAsLC6ICAQ1/IARBAEoEQCAAKALQAiEFIAAoAnAhByAAKALgAyIAKAIUIQogACgCECELIAAoAgwhDCAAKAIIIQ0DQCAEIQggBwRAIAJBAnQiACABKAIIaigCACEOIAEoAgQgAGooAgAhDyABKAIAIABqKAIAIRAgAygCACEEQQAhAANAIAAgD2otAAAhBiAEIAUgACAQai0AACIJIA0gACAOai0AAEECdCIRaigCAGpqLQAAOgAAIAQgBSAJIAsgEWooAgAgCiAGQQJ0IgZqKAIAakEQdWpqLQAAOgABIAQgBSAJIAYgDGooAgBqai0AADoAAiAEQQNqIQQgAEEBaiIAIAdHDQALCyADQQRqIQMgAkEBaiECIAhBAWshBCAIQQJODQALCwvOAgEIfyAEQQFOBEAgACgCcCIIQXxxIQogCEEDcSELIAhBAWtBA0khDANAIAQhCQJAIAhFDQAgASgCACACQQJ0aigCACEGIAMoAgAhBEEAIQAgCiEHIAxFBEADQCAEIAAgBmotAAAiBToAASAEIAU6AAIgBCAFOgAAIAQgBiAAQQFyai0AACIFOgAEIAQgBToABSAEIAU6AAMgBCAGIABBAnJqLQAAIgU6AAcgBCAFOgAIIAQgBToABiAEIAYgAEEDcmotAAAiBToACiAEIAU6AAsgBCAFOgAJIABBBGohACAEQQxqIQQgB0EEayIHDQALCyALIgdFDQADQCAEIAAgBmotAAAiBToAASAEIAU6AAIgBCAFOgAAIABBAWohACAEQQNqIQQgB0EBayIHDQALCyADQQRqIQMgAkEBaiECIAlBAWshBCAJQQJODQALCwvqAQEHfyAEQQBKBEAgACgCcCEHIAAoAuADKAIYIQUDQCAEIQAgBwRAIAJBAnQiBCABKAIIaigCACEIIAEoAgQgBGooAgAhCSABKAIAIARqKAIAIQogAygCACELQQAhBANAIAQgC2ogBSAEIAlqLQAAIgZBAnRBgAhyaigCACAFIAZBgAFqIgYgBCAKai0AAGpB/wFxQQJ0aigCAGogBSAGIAQgCGotAABqQf8BcUECdEGAEHJqKAIAakEQdjoAACAEQQFqIgQgB0cNAAsLIANBBGohAyACQQFqIQIgAEEBayEEIABBAk4NAAsLC9QBAQZ/IARBAEoEQCAAKAJwIQYgACgC4AMoAhghBQNAIAQhACAGBEAgAkECdCIEIAEoAghqKAIAIQcgASgCBCAEaigCACEIIAEoAgAgBGooAgAhCSADKAIAIQpBACEEA0AgBCAKaiAFIAQgB2otAABBAnRBgBByaigCACAFIAQgCGotAABBAnRBgAhyaigCACAFIAQgCWotAABBAnRqKAIAampBEHY6AAAgBEEBaiIEIAZHDQALCyADQQRqIQMgAkEBaiECIABBAWshBCAAQQJODQALCwsWACABKAIAIAIgA0EAIAQgACgCcBBwCzwAIAAgASACKAIAIAQgBSgCAEECdGogACgC3AMoAgwRBgAgBSAFKAIAQQFqNgIAIAIgAigCAEEBajYCAAu9AwEMfyACQQJ0IgIgASgCCGooAgAhBSABKAIEIAJqKAIAIQYgASgCACACaigCACEHIAMoAgAhASAAKALQAiECIAAoAtwDIgMoAhwhCCADKAIYIQsgAygCFCEMIAMoAhAhDSAAKAJwIgNBAXYiDgR/A0AgDCAGLQAAQQJ0IgRqKAIAIQMgCyAFLQAAQQJ0IglqKAIAIQogBCAIaigCACEPIAEgAiAJIA1qKAIAIgkgBy0AACIEamotAAA6AAAgASACIAQgCiAPakEQdSIKamotAAA6AAEgASACIAMgBGpqLQAAOgACIAEgAiAJIActAAEiBGpqLQAAOgADIAEgAiAEIApqai0AADoABCABIAIgAyAEamotAAA6AAUgAUEGaiEBIAdBAmohByAFQQFqIQUgBkEBaiEGIA5BAWsiDg0ACyAAKAJwBSADC0EBcQRAIAwgBi0AAEECdCIAaigCACEDIAsgBS0AAEECdCIFaigCACEGIAAgCGooAgAhCCABIAIgBy0AACIAIAUgDWooAgBqai0AADoAACABIAIgACAGIAhqQRB1amotAAA6AAEgASACIAAgA2pqLQAAOgACCwuKAgEEfyMAQRBrIgckAAJAAkAgACgC3AMiAygCJARAIANBIGpBACAEIAUoAgBBAnRqQQBBASADKAIoEHAgA0EANgIkIAUgBSgCAEEBajYCACADIAMoAixBAWs2AiwMAQsgAygCLCEIIAcgBCAFKAIAIglBAnRqIgooAgA2AgggBwJ/IAYgCWsiBCAIQQIgCEECSRsiBiAEIAZJGyIEQQJPBEAgCigCBAwBCyADQQE2AiQgAygCIAs2AgwgACABIAIoAgAgB0EIaiADKAIMEQYAIAMoAiQhACAFIAUoAgAgBGo2AgAgAyADKAIsIARrNgIsIAANAQsgAiACKAIAQQFqNgIACyAHQRBqJAALiQUBDn8gAkECdCIFIAEoAghqKAIAIQogASgCBCAFaigCACELIAEoAgAiBSACQQN0IgFqKAIAIQcgBSABQQRyaigCACEIIAMoAgQhAiADKAIAIQMgACgC0AIhBCAAKALcAyIBKAIcIQ4gASgCGCEPIAEoAhQhECABKAIQIREgACgCcCIBQQF2IgkEfwNAIBAgCy0AAEECdCIBaigCACEMIA8gCi0AAEECdCIGaigCACEFIAEgDmooAgAhASADIAQgBiARaigCACINIActAAAiBmpqLQAAOgAAIAMgBCAGIAEgBWpBEHUiBWpqLQAAOgABIAMgBCAGIAxqai0AADoAAiADIAQgDSAHLQABIgFqai0AADoAAyADIAQgASAFamotAAA6AAQgAyAEIAEgDGpqLQAAOgAFIAIgBCANIAgtAAAiAWpqLQAAOgAAIAIgBCABIAVqai0AADoAASACIAQgASAMamotAAA6AAIgAiAEIA0gCC0AASIBamotAAA6AAMgAiAEIAEgBWpqLQAAOgAEIAIgBCABIAxqai0AADoABSACQQZqIQIgCEECaiEIIANBBmohAyAHQQJqIQcgCkEBaiEKIAtBAWohCyAJQQFrIgkNAAsgACgCcAUgAQtBAXEEQCAQIAstAABBAnQiAGooAgAhCSAPIAotAABBAnQiAWooAgAhBSAAIA5qKAIAIQAgAyAEIAEgEWooAgAiASAHLQAAIgZqai0AADoAACADIAQgBiAAIAVqQRB1IgBqai0AADoAASADIAQgBiAJamotAAA6AAIgAiAEIAEgCC0AACIDamotAAA6AAAgAiAEIAAgA2pqLQAAOgABIAIgBCADIAlqai0AADoAAgsLGwEB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azYCBCACIAM2AgAMAQsgABCNAUUEQEEAIQEMAgsgACgCuAMhAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBAWsO/gEPERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERIBAgUJBQUFBQMEBQgFBQUPDw8PDw8PDwAHBgoQCxERDQ0NDQ0NDQ0NDQ0NDQ0NDRERERERERERDBERERERDhELIAAoAgAiAkHoADYCFCAAQQEgAigCBBECACAAKALQAyIBKAIMBEAgACgCACICQcAANgIUIAAgAigCABEAACAAKALQAyEBCyAAQgA3AOgBIABCADcA8AEgAEKBgoSIkKDAgAE3AIACIABCgYKEiJCgwIABNwD4ASAAQoWKlKjQoMGCBTcAkAIgAEKFipSo0KDBggU3AIgCIABCADcDsAIgAEEANgIoIABCADcDmAIgAEEAOgCsAiAAQoGABDcCpAIgAEEAOgCiAiAAQYECOwGgAiABQQE2AgwMFAtBACEBIABBAEEAQQAQZg0TDBILQQAhASAAQQBBAUEAEGYNEgwRC0EAIQEgAEEAQQBBARBmDREMEAtBACEBIABBAEEBQQEQZg0QDA8LIAAoAgAiAiABNgIYIAJBPzYCFCAAIAAoAgAoAgARAAAMDwsgACgCGCIGKAIEIQEgBigCACEDIAAoAtADKAIQRQRAIAAoAgAiAkE8NgIUIAJBGGpBsLYBQdAAEDwaIAAgACgCACgCABEAAAsgAUUEQCAAIAYoAgwRAQBFBEBBACEBDA8LIAYoAgAhAyAGKAIEIQELIAMtAAAhBCABQQFrIgIEfyADQQFqBSAAIAYoAgwRAQBFBEBBACEBDA8LIAYoAgQhAiAGKAIACyIBLQAAIQUgAkEBayIDBH8gAUEBagUgACAGKAIMEQEARQRAQQAhAQwPCyAGKAIEIQMgBigCAAshAiAAKAIA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ArgDNgIYIAAgACgCACgCABEAAAsgAwR/IAJBAWoFIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgALIgItAAAhBCADQQFrIgMEfyACQQFqBSAAIAEoAgwRAQBFBEBBACEBDAsLIAEoAgQhAyABKAIACyIFQQFqIQIgA0EBayEDIAUtAAAgBEEIdHJB/wFHDQAgA0UEQCAAIAEoAgwRAQBFBEBBACEBDAsLIAEoAgQhAyABKAIAIQILIAJBAWohBCADQQFrIQMgAi0AAEEDRwRAIAQhAgwBCyADRQRAIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgAhBAsgBEEBaiECIANBAWshAyAAKALYASIHKAJYIAQtAABHDQAgA0UEQCAAIAEoAgwRAQBFBEBBACEBDAsLIAAoAtgBIQcgASgCBCEDIAEoAgAhAgsgAkEBaiEEIANBAWshAyAHKAIAIAItAABHBEAgBCECDAELIANFBEAgACABKAIMEQEARQRAQQAhAQwLCyAAKALYASEHIAEoAgQhAyABKAIAIQQLIARBAWohAiADQQFrIQMgBygCsAEgBC0AAEcNACADRQRAIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgAhAgsgAkEBaiEEIANBAWshAyACLQAAQYABRwRAIAQhAgwBCyADRQRAIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgAhBAsgBC0AACEFIANBAWsiAwR/IARBAWoFIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgALIgRBAWohAiADQQFrIQMgBC0AACAFQQh0cg0AIANFBEAgACABKAIMEQEARQRAQQAhAQwLCyABKAIEIQMgASgCACECCyACLQAAIQQgA0EBayIDBH8gAkEBagUgACABKAIMEQEARQRAQQAhAQwLCyABKAIEIQMgASgCAAsiBUEBaiECIANBAWshAyAFLQAAIARBCHRyDQAgA0UEQCAAIAEoAgwRAQBFBEBBACEBDAsLIAEoAgQhAyABKAIAIQILIAJBAWohBCADQQFrIQMgAi0AAARAIAQhAgwBCyADRQRAIAAgASgCDBEBAEUEQEEAIQEMCwsgASgCBCEDIAEoAgAhBAsgBC0AACEFIANBAWsiAwR/IARBAWoFIAAg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aW5nIHdvcmsgb3ZlcmZsb3cuCgBPdXQgb2YgbWVtb3J5ISEKAE91dCBvZiBtZW1vcnkhIQoAPz8/IDEKAE1hcmtlciBPSy4AT3V0IG9mIG1lbW9yeSEhCgBPdXQgb2YgbWVtb3J5ISEKAE91dCBvZiBtZW1vcnkhIQoAT3V0IG9mIG1lbW9yeSEhCgAgCQoNAE91dCBvZiBtZW1vcnkhIQoAT3V0IG9mIG1lbW9yeSEhCgAgPT09IG1hdHJpeCAoJWQsJWQpID09PQoAd2IAYXJnbENhbWVyYUZydXN0dW1SSCgpOiBhclBhcmFtRGVjb21wTWF0KCkgaW5kaWNhdGVkIHBhcmFtZXRlciBlcnJvci4KAE91dCBvZiBtZW1vcnkhIQoAID09PSB2ZWN0b3IgKCVkKSA9PT0KAERhdGEgbnVtIGVycm9yISEKAEVycm9yOiBtYWxsb2MKAEVycm9yOiBtYWxsb2MKAEVycm9yOiBtYWxsb2MKAEVycm9yOiBtYWxsb2MKAEVycm9yIDE6IGljcEdldEluaXRYdzJYYwoAZGVidWcAJXMvJXMAT3V0IG9mIG1lbW9yeSEhCgBPdXQgb2YgbWVtb3J5ISEKAE91dCBvZiBtZW1vcnkhIQoAJXMuJXMAJXMuJXMAJXMuJXMAZnNldAAjIyMgRmVhdHVyZSBjYW5kaWRhdGVzIGZvciB0cmFja2luZyBhcmUgb3ZlcmZsb3cuCgBTdGFydCB0cmFja2luZ190aHJlYWQgIyVkLgoAT3V0IG9mIG1lbW9yeSEhCgBPdXQgb2YgbWVtb3J5ISEKAE91dCBvZiBtZW1vcnkhIQoAa3BtRGVsZXRlUmVmRGF0YVNldCgpOiBOVUxMIHJlZkRhdGFTZXRQdHIvcmVmSW1hZ2UuCgAsAE91dCBvZiBtZW1vcnkhIQoAT3V0IG9mIG1lbW9yeSEhCgBBc3NlcnRpb24gYHB5cmFtaWQtPnNpemUoKSA+IDBgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGB3aWR0aCA+PSA1YCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgd2lkdGggPj0gMWAgZmFpbGVkIGluIABBc3NlcnRpb24gYGltLndpZHRoKCkgPT0gaW0uc3RlcCgpL3NpemVvZihmbG9hdClgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGAoc3JjX3dpZHRoJTIpID09IDBgIGZhaWxlZCBpbiAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBBc3NlcnRpb24gYHggPj0gbU1pblhgIGZhaWxlZCBpbiAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAlbS0lZC0lWS0lSC0lTS0lUwBBc3NlcnRpb24gYHdpZHRoID4gMGAgZmFpbGVkIGluIABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAEFzc2VydGlvbiBgbVN0YXJ0VGltZSA+PSAwYCBmYWlsZWQgaW4gAFVua25vd24gb3IgdW5zdXBwb3J0ZWQgbGFiZWxpbmcgdGhyZXNob2xkIG1vZGUgcmVxdWVzdGVkLiBTZXQgdG8gbWFudWFsLgoAPz8/IDIKAFBhdHRlcm4gZXh0cmFjdGlvbiBmYWlsZWQuAEVycm9yOiB1bnN1cHBvcnRlZCBwaXhlbCBmb3JtYXQuCgBFcnJvcjogTlVMTCBwYXR0SGFuZGxlLgoAdwBBUl9QSVhFTF9GT1JNQVRfUkdCAFNJWkUgPSAlZCwgJWQKAEVycm9yICglZCk6IHVuYWJsZSB0byBvcGVuIGNhbWVyYSBwYXJhbWV0ZXJzIGZpbGUgIiVzIiBmb3Igd3JpdGluZy4KACVzLiVzAE91dCBvZiBtZW1vcnkhIQoARXJyb3I6IGljcEdldEpfVV9YYwBFcnJvciAyOiBpY3BHZXRJbml0WHcyWGMKAGluZm8AcmIAVHJhY2tpbmcgdGhyZWFkID0gJWQKACVzJXMAJXMuJXMAcgB3YgByYgAlcy4lcwBPdXQgb2YgbWVtb3J5ISEKAEVuZCB0cmFja2luZ190aHJlYWQgIyVkLgoAa3BtRGVsZXRlUmVmRGF0YVNldCgpOiAwIHhzaXplL3lzaXplL2RwaS4KAAoAJXMuJXMAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9kZXRlY3RvcnMvRG9HX3NjYWxlX2ludmFyaWFudF9kZXRlY3Rvci5jcHAAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9kZXRlY3RvcnMvZ2F1c3NpYW5fc2NhbGVfc3BhY2VfcHlyYW1pZC5jcHAAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9kZXRlY3RvcnMvaGFycmlzLmNwcAAvaG9tZS93YWx0ZXIva2Fsd2FsdC1naXRodWIvRmVhdHVyZVNFVC1EaXNwbGF5L2Vtc2NyaXB0ZW4vV2ViQVJLaXRMaWIvbGliL1NSQy9LUE0vRnJlYWtNYXRjaGVyL2RldGVjdG9ycy9vcmllbnRhdGlvbl9hc3NpZ25tZW50LmNwcAAvaG9tZS93YWx0ZXIva2Fsd2FsdC1naXRodWIvRmVhdHVyZVNFVC1EaXNwbGF5L2Vtc2NyaXB0ZW4vV2ViQVJLaXRMaWIvbGliL1NSQy9LUE0vRnJlYWtNYXRjaGVyL2RldGVjdG9ycy9weXJhbWlkLmNwcABJRCBhbHJlYWR5IGV4aXN0cwAvaG9tZS93YWx0ZXIva2Fsd2FsdC1naXRodWIvRmVhdHVyZVNFVC1EaXNwbGF5L2Vtc2NyaXB0ZW4vV2ViQVJLaXRMaWIvbGliL1NSQy9LUE0vRnJlYWtNYXRjaGVyL21hdGNoZXJzL2hvdWdoX3NpbWlsYXJpdHlfdm90aW5nLmNwcABBc3NlcnRpb24gYHB5cmFtaWRgIGZhaWxlZCBpbiAAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9mcmFtZXdvcmsvaW1hZ2UuY3BwAC9ob21lL3dhbHRlci9rYWx3YWx0LWdpdGh1Yi9GZWF0dXJlU0VULURpc3BsYXkvZW1zY3JpcHRlbi9XZWJBUktpdExpYi9saWIvU1JDL0tQTS9GcmVha01hdGNoZXIvZnJhbWV3b3JrL3RpbWVycy5jcHAATUFOVUFMAD8/PyAzCgBHZW5lcmljIGVycm9yIGR1cmluZyBtYXRjaGluZyBwaGFzZS4ARXJyb3I6IGNhbid0IGxvYWQgcGF0dGVybiBmcm9tIE5VTEwgYnVmZmVyLgoAJTRkAEFSX1BJWEVMX0ZPUk1BVF9CR1IAICUxMGcARGlzdG9ydGlvbiBmYWN0b3I6IGsxPSUxLjEwZiwgazI9JTEuMTBmLCBwMT0lMS4xMGYsIHAyPSUxLjEwZgoAJXMlcwoAd2IAICUxMGcARXJyb3IgaWNwR2V0Sl9VX1MKAD09PT09PSAlcyA9PT09PT09PQoARXJyb3IgMzogaWNwR2V0SW5pdFh3MlhjCgB3YXJuaW5nAHdiAHJiAHdiAE91dCBvZiBtZW1vcnkhIQoARXJyb3Igc2F2aW5nIGZlYXR1cmUgbWFwOiBlcnJvciB3cml0aW5nIGRhdGEuCgBGaWxlIG9wZW4gZXJyb3IuICVzCgByAEVycm9yOiBtYWxsb2MKAE91dCBvZiBtZW1vcnkhIQoAa3BtU2V0UmVmRGF0YVNldCgpOiBOVUxMIGtwbUhhbmRsZS9maWxlbmFtZS4KACBsaW5lIAAgbGluZSAAIGxpbmUgACBsaW5lIAAgbGluZSAAQnVpbGQgUHlyYW1pZAAgbGluZSAAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9tYXRjaGVycy9mcmVhay5oACBsaW5lIAAgbGluZSAAQVVUT19NRURJQU4ASW5zdWZmaWNpZW50IGNvbnRyYXN0IGR1cmluZyBtYXRjaGluZy4ARXJyb3I6IG91dCBvZiBtZW1vcnkuCgBBUl9QSVhFTF9GT1JNQVRfUkdCQQAgICAgICAgICAgICAgICAgICBmeD0lZiwgZnk9JWYsIHgwPSVmLCB5MD0lZiwgcz0lZgoAAEVycm9yOiBVbmFibGUgdG8gb3BlbiBmaWxlICclcycgZm9yIHdyaXRpbmcuCgBFcnJvciBpY3BHZXRVX2Zyb21fWF9ieV9NYXRYMlUKACU3LjVmIABFcnJvciA0OiBpY3BHZXRJbml0WHcyWGMKAGVycm9yAEVycm9yIGFsbG9jYXRpbmcgbWVtb3J5LgoARXJyb3I6IHVuYWJsZSB0byBvcGVuIGZpbGUgJyVzJXMnIGZvciByZWFkaW5nLgoARXJyb3I6IFVuYWJsZSB0byBvcGVuIGZpbGUgJyVzJyBmb3Igd3JpdGluZy4KACVkAHJiAE91dCBvZiBtZW1vcnkhIQoARXJyb3Igb3BlbmluZyBmaWxlICclcyc6IABGcmVhayBmZWF0dXJlcyAtICVkAHJiADogADogADogADogADogAEV4dHJhY3QgRmVhdHVyZXMAOiAAIGxpbmUgADogADogAEFVVE9fT1RTVQBCYXJjb2RlIG1hdGNoaW5nIGNvdWxkIG5vdCBmaW5kIGNvcnJlY3QgYmFyY29kZSBsb2NhdG9yIHBhdHRlcm4uAFBhdHRlcm4gRGF0YSByZWFkIGVycm9yISEKAEFSX1BJWEVMX0ZPUk1BVF9CR1JBAERpc3RvcnRpb24gZmFjdG9yID0gJWYgJWYgJWYgJWYgJWYgJWYKAHJiAHJiAEVycm9yIGljcEdldFhjX2Zyb21fWHdfYnlfTWF0WHcyWGMKAEVycm9yIDU6IGljcEdldEluaXRYdzJYYwoAWyVzXSAARXJyb3Igb3BlbmluZyAnJXMnLgoARXJyb3IgcmVhZGluZyBpbWFnZVNldC4KAHJiACVzAE91dCBvZiBtZW1vcnkhIQoAUmVhZCBlcnJvciEhCgAlcyVzCgBFcnJvciB3aGlsZSBhZGRpbmcgcmVmZXJlbmNlIGRhdGEgc2V0OiBrcG1HZW5SZWZEYXRhU2V0KCkgZmFpbGVkLgoAQ2FuJ3Qgb3BlbiBKUEVHIGZpbGUgJyVzJwoAUHlyYW1pZCBpcyBub3QgYWxsb2NhdGVkAEltYWdlIGlzIHRvbyBzbWFsbAB3cCBtdXN0IGJlIGF0IGxlYXN0IDEAU3RlcCBzaXplIG11c3QgYmUgZXF1YWwgdG8gd2lkdGggZm9yIG5vdwBTb3VyY2Ugd2lkdGggbXVzdCBiZSBldmVuAFslc10gWyVzXSBbJXNdIDogRm91bmQgJWQgZmVhdHVyZXMAeCBvdXQgb2YgcmFuZ2UAOiAAV2lkdGggY2Fubm90IGJlIHplcm8AQ2xvY2sgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQAQVVUT19BREFQVElWRQBCYXJjb2RlIG1hdGNoaW5nIGVycm9yIGRldGVjdGlvbi9jb3JyZWN0aW9uIGZvdW5kIHVucmVjb3ZlcmFibGUgZXJyb3IuAEVycm9yIHJlYWRpbmcgcGF0dGVybiBmaWxlICclcycuCgBBUl9QSVhFTF9GT1JNQVRfQUJHUgBEaXN0b3J0aW9uIGZhY3RvciA9ICVmICVmICVmICVmICVmCgBFcnJvciAoJWQpOiB1bmFibGUgdG8gb3BlbiBjYW1lcmEgcGFyYW1ldGVycyBmaWxlICIlcyIgZm9yIHJlYWRpbmcuCgBFcnJvcjogVW5hYmxlIHRvIG9wZW4gZmlsZSAnJXMnIGZvciByZWFkaW5nLgoARXJyb3IgPSAlZgoARXJyb3IgNjogaWNwR2V0SW5pdFh3MlhjCgBFcnJvciBjcmVhdGluZyBmdWxsIGZpbGUgcGF0aCBmcm9tICclcycgYW5kICclcycASW1hZ2VzZXQgY29udGFpbnMgJWQgaW1hZ2VzLgoARXJyb3I6IFVuYWJsZSB0byBvcGVuIGZpbGUgJyVzJyBmb3IgcmVhZGluZy4KACVmACAgICAgICAgIEltYWdlU2l6ZSA9ICU3ZFtwaXhlbF0KAHdiAAA9PT09PT09PT0gJWQgPT09PT09PT09PT0KACVzJXMKAEFzc2VydGlvbiBgbUltYWdlcy5zaXplKCkgPiAwYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgaGVpZ2h0ID49IDVgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBoZWlnaHQgPj0gMWAgZmFpbGVkIGluIABBc3NlcnRpb24gYHggPj0gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYGRzdCAhPSAwYCBmYWlsZWQgaW4gACBJTkZPICAAQXNzZXJ0aW9uIGB4IDwgbU1heFhgIGZhaWxlZCBpbiAAUHlyYW1pZCBpcyBOVUxMAEFzc2VydGlvbiBgaGVpZ2h0ID4gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYG1TdG9wVGltZSA+PSAwYCBmYWlsZWQgaW4gAEFVVE9fQlJBQ0tFVElORwBNYXRjaGluZyBjb25maWRlbmNlIGN1dG9mZiB2YWx1ZSBub3QgcmVhY2hlZC4AJXMlcwoAQVJfUElYRUxfRk9STUFUX01PTk8ARGlzdG9ydGlvbiBmYWN0b3IgPSAlZiAlZiAlZiAlZgoARXJyb3IgKCVkKTogdW5hYmxlIHRvIGRldGVybWluZSBmaWxlIGxlbmd0aC4ARXJyb3IgaWNwMkdldFRTCgBFcnJvciA3OiBpY3BHZXRJbml0WHcyWGMKAEVycm9yIGluIG9wZW5pbmcgJyVzJyBpbiB6aXBmaWxlLgoARmFsbGluZyBiYWNrIHRvIHJlYWRpbmcgJyVzJXMnIGluIEFSVG9vbEtpdCB2NC54IGZvcm1hdC4KAEVycm9yIHJlYWRpbmcgSlBFRyBmaWxlLgoAJWYgJWYgJWYgJWYARXh0cmFjdGVkIGZlYXR1cmVzID0gJTdkW3BpeGVsXQoARXJyb3Igc2F2aW5nIGZlYXR1cmUgc2V0OiBlcnJvciB3cml0aW5nIGRhdGEuCgBPdXQgb2YgbWVtb3J5ISEKAEVycm9yIHdoaWxlIGFkZGluZyByZWZlcmVuY2UgZGF0YSBzZXQ6IGtwbU1lcmdlUmVmRGF0YVNldCgpIGZhaWxlZC4KAABMYXBsYWNpYW4gcHlyYW1pZCBoYXMgbm90IGJlZW4gYWxsb2NhdGVkAEFzc2VydGlvbiBgaW1hZ2UudHlwZSgpID09IElNQUdFX1VJTlQ4YCBmYWlsZWQgaW4gAGhwIG11c3QgYmUgYXQgbGVhc3QgMQB4IG11c3QgYmUgcG9zaXRpdmUARGVzdGluYXRpb24gaXMgTlVMTABCdWlsZCBJbmRleABBc3NlcnRpb24gYHkgPj0gbU1pbllgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBzdG9yZS5zaXplKCkgPT0gcG9pbnRzLnNpemUoKWAgZmFpbGVkIGluIABIZWlnaHQgY2Fubm90IGJlIHplcm8AQ2xvY2sgaGFzIG5vdCBiZWVuIHN0b3BwZWQATGFiZWxpbmcgdGhyZXNob2xkIG1vZGUgc2V0IHRvICVzLgoATWF4aW11bSBhbGxvd2FibGUgcG9zZSBlcnJvciBleGNlZWRlZC4AAEFSX1BJWEVMX0ZPUk1BVF9BUkdCAEVycm9yOiBzdXBwbGllZCBmaWxlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhbiBBUlRvb2xLaXQgY2FtZXJhIHBhcmFtZXRlciBmaWxlLgoARXJyb3IgaW4gb3BlbmluZyAnJXMnIGZvciByZWFkaW5nCgB3YgBFcnJvciByZWFkaW5nIEpQRUcgZmlsZSBoZWFkZXIuCgAgRmlsdGVyZWQgZmVhdHVyZXMgPSAlN2RbcGl4ZWxdCgAlZABrcG1EZWxldGVSZWZEYXRhU2V0KCk6IE5VTEwgcmVmRGF0YVNldFB0cjEvcmVmRGF0YVNldFB0cjIuCgBDYW4ndCByZWFkIEpQRUcgZmlsZSAnJXMnCgBBc3NlcnRpb24gYHB5cmFtaWQtPm51bU9jdGF2ZXMoKSA+IDBgIGZhaWxlZCBpbiAASW1hZ2UgbXVzdCBiZSBncmF5c2NhbGUAQXNzZXJ0aW9uIGBpKzErY2h1bmtfc2l6ZSA8IHdpZHRoYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgeCA8IG1HcmFkaWVudHNbb2N0YXZlKm1OdW1TY2FsZXNQZXJPY3RhdmUrc2NhbGVdLndpZHRoKClgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBzcmMgIT0gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYHB5cmFtaWRgIGZhaWxlZCBpbiAAeSBvdXQgb2YgcmFuZ2UARmVhdHVyZSBzdG9yZSBoYXMgbm90IGJlZW4gYWxsb2NhdGVkAEFzc2VydGlvbiBgc3RlcCA+PSB3aWR0aGAgZmFpbGVkIGluIABbJXNdIFslc10gWyVzXSA6ICVzOiAlZiBtcwBFcnJvcjogVW5zdXBwb3J0ZWQgcGl4ZWwgZm9ybWF0ICglZCkgcmVxdWVzdGVkLgoATXVsdGktbWFya2VyIHBvc2UgZXJyb3IgdmFsdWUgZXhjZWVkZWQuAEFSX1BJWEVMX0ZPUk1BVF8ydnV5ACU3LjVmIABFcnJvciAoJWQpOiB1bmFibGUgdG8gcmVhZCBmcm9tIGZpbGUuAEVycm9yIGluIHJlYWRpbmcgJyVzJy4KAEVycm9yOiB1bmFibGUgdG8gb3BlbiBmaWxlICclcycgZm9yIHdyaXRpbmcuCgANJTRkLyU0ZC4ACiMjIyBTdXJmYWNlIE5vLiVkICMjIwoAa3BtRGVsZXRlUmVmRGF0YVNldCgpOiBOVUxMIHJlZkRhdGFTZXRQdHIuCgBrcG1TZXRSZWZEYXRhU2V0KCk6IE5VTEwga3BtSGFuZGxlL3JlZkRhdGFTZXQuCgBQeXJhbWlkIGRvZXMgbm90IGNvbnRhaW4gYW55IGxldmVscwBBc3NlcnRpb24gYGltYWdlLmNoYW5uZWxzKCkgPT0gMWAgZmFpbGVkIGluIABFeHRlbmRpbmcgYmV5b25kIHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UAeCBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgaW1hZ2Ugd2lkdGgAU291cmNlIGlzIE5VTEwAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9tYXRjaGVycy92aXN1YWxfZGF0YWJhc2UuaABBc3NlcnRpb24gYHkgPCBtTWF4WWAgZmFpbGVkIGluIABBc3NlcnRpb24gYG51bV9wb2ludHMgPT0gcG9pbnRzLnNpemUoKWAgZmFpbGVkIGluIABTdGVwIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSB3aWR0aAAgSU5GTyAgAFJlamVjdGVkIGZyZXF1ZW50bHkgbWlzcmVjb2duaXNlZCBtYXRyaXggbWFya2VyLgBBUl9QSVhFTF9GT1JNQVRfeXV2cwBFcnJvcjogc3VwcGxpZWQgYnVmZmVyIGRvZXMgbm90IGFwcGVhciB0byBiZSBBUlRvb2xLaXQgY2FtZXJhIHBhcmFtZXRlcnMuCgBFcnJvciBpbiB3cml0aW5nICclcycgaW4gdGhlIHppcGZpbGUuCgBFcnJvciBzYXZpbmcgaW1hZ2Ugc2V0OiBlcnJvciB3cml0aW5nIGRhdGEuCgAKACVzAGtwbVNhdmVSZWZEYXRhU2V0KCk6IE5VTEwgZmlsZW5hbWUvcmVmRGF0YVNldC4KAGtwbVNldFJlZkRhdGFTZXQoKTogcmVmRGF0YVNldC4KAEFzc2VydGlvbiBgZHluYW1pY19jYXN0PGNvbnN0IEJpbm9taWFsUHlyYW1pZDMyZio+KHB5cmFtaWQpYCBmYWlsZWQgaW4gAEltYWdlIG11c3QgaGF2ZSAxIGNoYW5uZWwAQXNzZXJ0aW9uIGBidWNrZXRbMF0uZmlyc3QgPj0gYnVja2V0W25dLmZpcnN0YCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgeSA+PSAwYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgc3JjX3dpZHRoID4gMGAgZmFpbGVkIGluIAAgbGluZSAAQXNzZXJ0aW9uIGBhbmdsZSA+IC1QSWAgZmFpbGVkIGluIABTaG91bGQgYmUgc2FtZSBzaXplAEFzc2VydGlvbiBgY2hhbm5lbHMgPiAwYCBmYWlsZWQgaW4gAEF1dG8gdGhyZXNob2xkIChicmFja2V0KSBtYXJrZXIgY291bnRzIC1bJTNkOiAlM2RdIFslM2Q6ICUzZF0gWyUzZDogJTNkXSsuCgBBUl9QSVhFTF9GT1JNQVRfUkdCXzU2NQBGaWVsZC1vZi12aWV3IHZlcnRpY2FsID0gJS4xZiwgaG9yaXpvbnRhbCA9ICUuMWYgZGVncmVlcywgYXNwZWN0IHJhdGlvID0gJS4zZgoARXJyb3IgKCVkKTogdW5hYmxlIHRvIG9wZW4gZXh0ZXJuYWwgcGFyYW1ldGVycyBmaWxlICIlcyIgZm9yIHdyaXRpbmcuCgBFcnJvciBpbiBjbG9zaW5nICVzIGluIHRoZSB6aXBmaWxlLgoATWF4IGZlYXR1cmUgPSAlZAoAICBSZWFkIEltYWdlU2V0LgoARXJyb3Igc2F2aW5nIEtQTSBkYXRhOiB1bmFibGUgdG8gb3BlbiBmaWxlICclcyVzJXMnIGZvciB3cml0aW5nLgoAT3V0IG9mIG1lbW9yeSEhCgBPbmx5IGJpbm9taWFsIHB5cmFtaWQgaXMgc3VwcG9ydGVkAEFzc2VydGlvbiBgbVB5cmFtaWQuc2l6ZSgpID09IG1OdW1PY3RhdmVzKm1OdW1TY2FsZXNQZXJPY3RhdmVgIGZhaWxlZCBpbiAAbnRoX2VsZW1lbnQgZmFpbGVkAHkgbXVzdCBiZSBwb3NpdGl2ZQBXaWR0aCBtdXN0IGJlIHBvc2l0aXZlADogAGFuZ2xlIG91dCBvZiByYW5nZQBBc3NlcnRpb24gYG9jdGF2ZSA+PSAwYCBmYWlsZWQgaW4gAE51bWJlciBvZiBjaGFubmVscyBjYW5ub3QgYmUgemVybwBBdXRvIHRocmVzaG9sZCAoYnJhY2tldCkgYWRqdXN0ZWQgdGhyZXNob2xkIHRvICVkLgoAQVJfUElYRUxfRk9STUFUX1JHQkFfNTU1MQBFcnJvciAoJWQpOiB1bmFibGUgdG8gb3BlbiBleHRlcm5hbCBwYXJhbWV0ZXJzIGZpbGUgIiVzIiBmb3IgcmVhZGluZy4KAEVycm9yIGluIGNsb3NpbmcgJyVzJy4KACUzZDogKCUzZCwlM2QpIDogJWYgbWluPSVmIG1heD0lZiwgc2Q9JWYKAEVycm9yIG9wZW5pbmcgZmlsZSAnJXMuaXNldCcuCgAuAHBvaW50cy0lZAoAQXNzZXJ0aW9uIGBkLnR5cGUoKSA9PSBJTUFHRV9GMzJgIGZhaWxlZCBpbiAAUHlyYW1pZCBoYXMgbm90IGJlZW4gYWxsb2NhdGVkIHlldABBc3NlcnRpb24gYHBbMF0gPiBwbTFbLTFdYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgeSA8IG1HcmFkaWVudHNbb2N0YXZlKm1OdW1TY2FsZXNQZXJPY3RhdmUrc2NhbGVdLmhlaWdodCgpYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgc3JjX2hlaWdodCA+IDBgIGZhaWxlZCBpbiAAUHlyYW1pZCBpcyBOVUxMAEFzc2VydGlvbiBgYW5nbGUgPD0gUElgIGZhaWxlZCBpbiAAL2hvbWUvd2FsdGVyL2thbHdhbHQtZ2l0aHViL0ZlYXR1cmVTRVQtRGlzcGxheS9lbXNjcmlwdGVuL1dlYkFSS2l0TGliL2xpYi9TUkMvS1BNL0ZyZWFrTWF0Y2hlci9kZXRlY3RvcnMvZ2F1c3NpYW5fc2NhbGVfc3BhY2VfcHlyYW1pZC5oAEFzc2VydGlvbiBgbURhdGEuZ2V0KClgIGZhaWxlZCBpbiAAQXV0byB0aHJlc2hvbGQgKCVzKSBhZGp1c3RlZCB0aHJlc2hvbGQgdG8gJWQuCgBBUl9QSVhFTF9GT1JNQVRfUkdCQV80NDQ0AFslIC4zZiAlIC4zZiAlIC4zZl0gWyUgNi4xZl0KAEVycm9yICglZCk6IHVuYWJsZSB0byBvcGVuIG9wdGljYWwgcGFyYW1ldGVycyBmaWxlICIlcyIgZm9yIHdyaXRpbmcuCgAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KACAgICBlbmQuCgAAa3BtU2V0UmVmRGF0YVNldEZpbGUoKTogTlVMTCBrcG1IYW5kbGUvZmlsZW5hbWUuCgBPbmx5IEYzMiBpbWFnZXMgc3VwcG9ydGVkAEFzc2VydGlvbiBgaW1hZ2Uud2lkdGgoKSA9PSBtUHlyYW1pZFswXS53aWR0aCgpYCBmYWlsZWQgaW4gAFNob3VsZCBiZSBtYXhpbWEAeSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgaW1hZ2UgaGVpZ2h0AEhlaWdodCBtdXN0IGJlIHBvc2l0aXZlAEFzc2VydGlvbiBgZGV0ZWN0b3JgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBzY2FsZSA+PSBtTWluU2NhbGVgIGZhaWxlZCBpbiAAT2N0YXZlIG11c3QgYmUgcG9zaXRpdmUARGF0YSBwb2ludGVyIGlzIE5VTEwAbWVkaWFuAEFSX1BJWEVMX0ZPUk1BVF80MjB2AEVycm9yICglZCk6IHVuYWJsZSB0byBvcGVuIG9wdGljYWwgcGFyYW1ldGVycyBmaWxlICIlcyIgZm9yIHJlYWRpbmcuCgAlM2QsICUzZDogbWF4X3NpbSA9ICVmCgAgIFJlYWQgRmVhdHVyZVNldC4KAEVycm9yIHNhdmluZyBLUE0gZGF0YTogZXJyb3Igd3JpdGluZyBkYXRhLgoAQ2Fubm90IGZpbmQgdGhlIHBhZ2UgZm9yIHNraXBwaW5nLgoAQXNzZXJ0aW9uIGBpbTEudHlwZSgpID09IElNQUdFX0YzMmAgZmFpbGVkIGluIABJbWFnZSBvZiB3cm9uZyBzaXplIGZvciBweXJhbWlkAEFzc2VydGlvbiBgcFswXSA+IHBtMVswXWAgZmFpbGVkIGluIABBc3NlcnRpb24gYGcuY2hhbm5lbHMoKSA9PSAyYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgc3JjX3N0ZXAgPiAwYCBmYWlsZWQgaW4gAERldGVjdG9yIGlzIE5VTEwAc2NhbGUgb3V0IG9mIHJhbmdlAEFzc2VydGlvbiBgb2N0YXZlIDwgbU51bU9jdGF2ZXNgIGZhaWxlZCBpbiAAVW5hYmxlIHRvIGFsbG9jYXRlIGltYWdlIGRhdGEAT3RzdQBBUl9QSVhFTF9GT1JNQVRfNDIwZgAlNy40ZiAARXJyb3Igb3BlbmluZyBmaWxlICclcy5mc2V0Jy4KAGtwbUxvYWRSZWZEYXRhU2V0KCk6IE5VTEwgZmlsZW5hbWUvcmVmRGF0YVNldFB0ci4KAGtwbU1hdGNoaW5nKCk6IE5VTEwga3BtSGFuZGxlL2luSW1hZ2VMdW1hLgoAQXNzZXJ0aW9uIGBpbTIudHlwZSgpID09IElNQUdFX0YzMmAgZmFpbGVkIGluIABBc3NlcnRpb24gYGltYWdlLmhlaWdodCgpID09IG1QeXJhbWlkWzBdLmhlaWdodCgpYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgcFswXSA+IHBtMVsxXWAgZmFpbGVkIGluIABOdW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDIAU3RlcCBtdXN0IGJlIHBvc2l0aXZlAEFzc2VydGlvbiBgcHlyYW1pZC0+aW1hZ2VzKCkuc2l6ZSgpID4gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYHNjYWxlIDwgbU1heFNjYWxlYCBmYWlsZWQgaW4gAE9jdGF2ZSBtdXN0IGJlIGxlc3MgdGhhbiBudW1iZXIgb2Ygb2N0YXZlcwBJbnZhbGlkIGltYWdlIHR5cGUAQVJfUElYRUxfRk9STUFUX05WMjEAJTNkLCAlM2Q6IG1heF9zaW0gPSAlZiwgKG1heCxtaW4pID0gJWYsICVmLCBzZCA9ICVmCgAgIFJlYWQgTWFya2VyU2V0LgoARXJyb3IgbG9hZGluZyBLUE0gZGF0YTogdW5hYmxlIHRvIG9wZW4gZmlsZSAnJXMlcyVzJyBmb3IgcmVhZGluZy4KAFBhZ2VbJWRdICBwcmU6JTNkLCBhZnQ6JTNkLCBlcnJvciA9ICVmCgBBc3NlcnRpb24gYGQuY2hhbm5lbHMoKSA9PSAxYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgZHN0LnR5cGUoKSA9PSBJTUFHRV9GMzJgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBwWzBdID4gcFstMV1gIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBtYXhfaGVpZ2h0ID4gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYGRzdF93aWR0aCA+IDBgIGZhaWxlZCBpbiAAUHlyYW1pZCBpcyBlbXB0eQBBc3NlcnRpb24gYHNpemUgPiAwYCBmYWlsZWQgaW4gAEFzc2VydGlvbiBgc2NhbGUgPj0gMGAgZmFpbGVkIGluIABhclV0aWxHZXRQaXhlbEZvcm1hdE5hbWU6IEVycm9yLCB1bnJlY29nbmlzZWQgcGl4ZWwgZm9ybWF0ICglZCkuCgBtcmsARXJyb3IgbG9hZGluZyBLUE0gZGF0YTogZXJyb3IgcmVhZGluZyBkYXRhLgoASlBFRyBmaWxlIGhhcyB1bnN1cHBvcnRlZCAlZC1jb21wb25lbnQgcGl4ZWxzCgBPbmx5IHNpbmdsZSBjaGFubmVsIGltYWdlcyBzdXBwb3J0ZWQARGVzdGluYXRpb24gaW1hZ2Ugc2hvdWxkIGJlIGEgZmxvYXQAQXNzZXJ0aW9uIGBwWzBdID4gcFsxXWAgZmFpbGVkIGluIABNYXhpbXVtIGJpbiBzaG91bGQgYmUgcG9zaXRpdmUAQXNzZXJ0aW9uIGBkc3Rfc3RlcCA+IDBgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBweXJhbWlkLT5pbWFnZXMoKVswXS53aWR0aCgpID09IGRldGVjdG9yLT53aWR0aCgpYCBmYWlsZWQgaW4gAHNpemUgbXVzdCBiZSBwb3NpdGl2ZQBTY2FsZSBtdXN0IGJlIHBvc2l0aXZlAE91dCBvZiBtZW1vcnkuCgBFcnJvciBvcGVuaW5nIGZpbGUgJyVzLm1yaycuCgBrcG1DaGFuZ2VQYWdlTm9PZlJlZkRhdGFTZXQoKTogTlVMTCByZWZEYXRhU2V0LgoAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQBBc3NlcnRpb24gYGltMS5jaGFubmVscygpID09IDFgIGZhaWxlZCBpbiAAVW5rbm93biBpbWFnZSB0eXBlAEFzc2VydGlvbiBgcFswXSA+IHBwMVstMV1gIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBoaXN0ICE9IE5VTExgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGAoc3JjX3dpZHRoJTIpID09IDFgIGZhaWxlZCBpbiAAUHlyYW1pZCBhbmQgZGV0ZWN0b3Igc2l6ZSBtaXNtYXRjaABBc3NlcnRpb24gYG1SZWZJbWFnZVdpZHRoID4gMGAgZmFpbGVkIGluIABBc3NlcnRpb24gYHNjYWxlIDwgbU51bVNjYWxlc1Blck9jdGF2ZWAgZmFpbGVkIGluIAAlJSUwMngAJWYgJWYgJWYgJWYAQXNzZXJ0aW9uIGBpbTIuY2hhbm5lbHMoKSA9PSAxYCBmYWlsZWQgaW4gAFVuc3VwcG9ydGVkIGltYWdlIHR5cGUAQXNzZXJ0aW9uIGBwWzBdID4gcHAxWzBdYCBmYWlsZWQgaW4gAC9ob21lL3dhbHRlci9rYWx3YWx0LWdpdGh1Yi9GZWF0dXJlU0VULURpc3BsYXkvZW1zY3JpcHRlbi9XZWJBUktpdExpYi9saWIvU1JDL0tQTS9GcmVha01hdGNoZXIvZGV0ZWN0b3JzL29yaWVudGF0aW9uX2Fzc2lnbm1lbnQuaABTb3VyY2Ugd2lkdGggbXVzdCBiZSBvZGQAQXNzZXJ0aW9uIGBweXJhbWlkLT5pbWFnZXMoKVswXS5oZWlnaHQoKSA9PSBkZXRlY3Rvci0+aGVpZ2h0KClgIGZhaWxlZCBpbiAAd2lkdGggbXVzdCBiZSBwb3NpdGl2ZQBTY2FsZSBtdXN0IGJlIGxlc3MgdGhhbiBudW1iZXIgb2Ygc2NhbGUgcGVyIG9jdGF2ZQAvcHJvYy9zZWxmL2V4ZQBUcmFuc2Zvcm1hdGlvbiBtYXRyaXggcmVhZCBlcnJvciEhCgBBc3NlcnRpb24gYGQud2lkdGgoKSA9PSBpbTIud2lkdGgoKWAgZmFpbGVkIGluIABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAEFzc2VydGlvbiBgcFswXSA+IHBwMVsxXWAgZmFpbGVkIGluIABIaXN0b2dyYW0gcG9pbnRlciBpcyBOVUxMAEFzc2VydGlvbiBgKGNodW5rX3NpemUlMik9PTBgIGZhaWxlZCBpbiAAQXNzZXJ0aW9uIGBhc3NpZ25tZW50LnNpemUoKSA9PSBudW1faW5kaWNlc2AgZmFpbGVkIGluIABBc3NlcnRpb24gYG1SZWZJbWFnZUhlaWdodCA+IDBgIGZhaWxlZCBpbiAAT2N0YXZlIG91dCBvZiByYW5nZQAlcyVzCgBqcGcASW1hZ2VzIG11c3QgaGF2ZSB0aGUgc2FtZSB3aWR0aABBc3NlcnRpb24gYCFpc2luZih1WzBdKWAgZmFpbGVkIGluIABBc3NlcnRpb24gYChmYmluKzAuNWYpID4gMCAmJiAoZmJpbi0wLjVmKSA8IG51bV9iaW5zYCBmYWlsZWQgaW4gAFVudGVzdGVkIGJlaGF2aW9yIGZvciBvZGQgY2h1bmsgc2l6ZQAvaG9tZS93YWx0ZXIva2Fsd2FsdC1naXRodWIvRmVhdHVyZVNFVC1EaXNwbGF5L2Vtc2NyaXB0ZW4vV2ViQVJLaXRMaWIvbGliL1NSQy9LUE0vRnJlYWtNYXRjaGVyL21hdGNoZXJzL2JpbmFyeV9oaWVyYXJjaGljYWxfY2x1c3RlcmluZy5oAGhlaWdodCBtdXN0IGJlIHBvc2l0aXZlAFNjYWxlIG91dCBvZiByYW5nZQBBoPgAC/YKEAcAALULAAB0EQAA4xMAAC5pc2V0AHJiAFJlYWRpbmcgJXMuZnNldAoAZnNldABFcnJvciByZWFkaW5nIGRhdGEgZnJvbSAlcy5mc2V0CgBwcmludGluZyBwb2ludGVyIGltZ0JXOiAlZAoATkZUIG51bWJlciBvZiBJbWFnZVNldDogJWkKAE5GVCBtYXJrZXIgd2lkdGg6ICVpCgBORlQgbWFya2VyIGhlaWdodDogJWkKAE5GVCBtYXJrZXIgZHBpOiAlaQoATkZUIG51bWJlciBvZiBGZWF0dXJlIHNldHM6ICVpCgBORlQgbnVtYmVyIG9mIGZlYXR1cmUgcG9pbnRzOiAlZAoATkZUIFBvaW50IHggY29vcmQ6ICVkCgBORlQgUG9pbnQgeSBjb29yZDogJWQKAGltZ0JXIGZpbGxlZAoAICBEb25lLgoAUmVhZCBGZWF0dXJlU2V0My4KAGZzZXQzAGZpbGUgb3BlbiBlcnJvcjogJXMuZnNldDMKACAgZW5kLgoAbnVtID0gJWQKAGltZ3NpemVQb2ludGVyOiAlZAoATG9hZGluZyBvZiBORlQgZGF0YSBjb21wbGV0ZS4KAFBhc3NpbmcgdGhlIGltZ0JXIHBvaW50ZXI6ICVkCgBpaWlpAEFsbG9jYXRlZCBpbWdCV3NpemUgJWQKAHNldHVwAF9yZWFkTkZUTWFya2VyAG5mdE1hcmtlcgB3aWR0aABoZWlnaHQAZHBpAG51bUZzZXRzAG51bUZwb2ludHMAaW1nQldzaXplAG5mdEZlYXR1cmVQb2ludHMAbmZ0UG9pbnRzAHBvaW50ZXIAbmZ0UG9pbnQAdmVjdG9yPG5mdFBvaW50PgAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQAAAABgegAAYHoAAGB6AABpaWlpAAAAACQ/AABgegAAnD8AADluZnRNYXJrZXIAAMR6AAAYPwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQAAAADEegAAaz8AAEh7AAAsPwAAAAAAAAEAAACUPwAAAAAAAGkAdmkAaWlpAHZpaWkATlN0M19fMjZ2ZWN0b3JJOG5mdFBvaW50TlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJOG5mdFBvaW50TlNfOWFsbG9jYXRvcklTMV9FRUVFAE5TdDNfXzIyMF9fdmVjdG9yX2Jhc2VfY29tbW9uSUxiMUVFRQAAxHoAACZAAABIewAA8D8AAAAAAAABAAAATEAAAAAAAABIewAAwj8AAAAAAAABAAAAVEAAAAAAAAA4bmZ0UG9pbnQAAADEegAAhEAAAHB1c2hfYmFjawByZXNpemUAc2l6ZQBnZXQAc2V0AFBOU3QzX18yNnZlY3Rvckk4bmZ0UG9pbnROU185YWxsb2NhdG9ySVMxX0VFRUUAAAAApHsAALZAAAAAAAAAbEAAAFBLTlN0M19fMjZ2ZWN0b3JJOG5mdFBvaW50TlNfOWFsbG9jYXRvcklTMV9FRUVFAKR7AAD4QAAAAQAAAGxAAABpaQB2AAAAAOhAAAAAegAA6EAAAJBAAAAAegAA6EAAAIR6AACQQAAAdmlpaWkAAACEegAAKEEAAJBBAABsQAAAhHoAAE4xMGVtc2NyaXB0ZW4zdmFsRQAAxHoAAHxBAEGggwEL8ygYegAAbEAAAIR6AACQQAAAaWlpaWkAQm9ndXMgbWVzc2FnZSBjb2RlICVkAEFMSUdOX1RZUEUgaXMgd3JvbmcsIHBsZWFzZSBmaXgATUFYX0FMTE9DX0NIVU5LIGlzIHdyb25nLCBwbGVhc2UgZml4AEJvZ3VzIGJ1ZmZlciBjb250cm9sIG1vZGUASW52YWxpZCBjb21wb25lbnQgSUQgJWQgaW4gU09TAEludmFsaWQgY3JvcCByZXF1ZXN0AERDVCBjb2VmZmljaWVudCBvdXQgb2YgcmFuZ2UARENUIHNjYWxlZCBibG9jayBzaXplICVkeCVkIG5vdCBzdXBwb3J0ZWQAQ29tcG9uZW50IGluZGV4ICVkOiBtaXNtYXRjaGluZyBzYW1wbGluZyByYXRpbyAlZDolZCwgJWQ6JWQsICVjAEJvZ3VzIEh1ZmZtYW4gdGFibGUgZGVmaW5pdGlvbgBCb2d1cyBpbnB1dCBjb2xvcnNwYWNlAEJvZ3VzIEpQRUcgY29sb3JzcGFjZQBCb2d1cyBtYXJrZXIgbGVuZ3RoAFdyb25nIEpQRUcgbGlicmFyeSB2ZXJzaW9uOiBsaWJyYXJ5IGlzICVkLCBjYWxsZXIgZXhwZWN0cyAlZABTYW1wbGluZyBmYWN0b3JzIHRvbyBsYXJnZSBmb3IgaW50ZXJsZWF2ZWQgc2NhbgBJbnZhbGlkIG1lbW9yeSBwb29sIGNvZGUgJWQAVW5zdXBwb3J0ZWQgSlBFRyBkYXRhIHByZWNpc2lvbiAlZABJbnZhbGlkIHByb2dyZXNzaXZlIHBhcmFtZXRlcnMgU3M9JWQgU2U9JWQgQWg9JWQgQWw9JWQASW52YWxpZCBwcm9ncmVzc2l2ZSBwYXJhbWV0ZXJzIGF0IHNjYW4gc2NyaXB0IGVudHJ5ICVkAEJvZ3VzIHNhbXBsaW5nIGZhY3RvcnMASW52YWxpZCBzY2FuIHNjcmlwdCBhdCBlbnRyeSAlZABJbXByb3BlciBjYWxsIHRvIEpQRUcgbGlicmFyeSBpbiBzdGF0ZSAlZABKUEVHIHBhcmFtZXRlciBzdHJ1Y3QgbWlzbWF0Y2g6IGxpYnJhcnkgdGhpbmtzIHNpemUgaXMgJXUsIGNhbGxlciBleHBlY3RzICV1AEJvZ3VzIHZpcnR1YWwgYXJyYXkgYWNjZXNzAEJ1ZmZlciBwYXNzZWQgdG8gSlBFRyBsaWJyYXJ5IGlzIHRvbyBzbWFsbABTdXNwZW5zaW9uIG5vdCBhbGxvd2VkIGhlcmUAQ0NJUjYwMSBzYW1wbGluZyBub3QgaW1wbGVtZW50ZWQgeWV0AFRvbyBtYW55IGNvbG9yIGNvbXBvbmVudHM6ICVkLCBtYXggJWQAVW5zdXBwb3J0ZWQgY29sb3IgY29udmVyc2lvbiByZXF1ZXN0AEJvZ3VzIERBQyBpbmRleCAlZABCb2d1cyBEQUMgdmFsdWUgMHgleABCb2d1cyBESFQgaW5kZXggJWQAQm9ndXMgRFFUIGluZGV4ICVkAEVtcHR5IEpQRUcgaW1hZ2UgKEROTCBub3Qgc3VwcG9ydGVkKQBSZWFkIGZyb20gRU1TIGZhaWxlZABXcml0ZSB0byBFTVMgZmFpbGVkAERpZG4ndCBleHBlY3QgbW9yZSB0aGFuIG9uZSBzY2FuAElucHV0IGZpbGUgcmVhZCBlcnJvcgBPdXRwdXQgZmlsZSB3cml0ZSBlcnJvciAtLS0gb3V0IG9mIGRpc2sgc3BhY2U/AEZyYWN0aW9uYWwgc2FtcGxpbmcgbm90IGltcGxlbWVudGVkIHlldABIdWZmbWFuIGNvZGUgc2l6ZSB0YWJsZSBvdmVyZmxvdwBNaXNzaW5nIEh1ZmZtYW4gY29kZSB0YWJsZSBlbnRyeQBNYXhpbXVtIHN1cHBvcnRlZCBpbWFnZSBkaW1lbnNpb24gaXMgJXUgcGl4ZWxzAEVtcHR5IGlucHV0IGZpbGUAUHJlbWF0dXJlIGVuZCBvZiBpbnB1dCBmaWxlAENhbm5vdCB0cmFuc2NvZGUgZHVlIHRvIG11bHRpcGxlIHVzZSBvZiBxdWFudGl6YXRpb24gdGFibGUgJWQAU2NhbiBzY3JpcHQgZG9lcyBub3QgdHJhbnNtaXQgYWxsIGRhdGEASW52YWxpZCBjb2xvciBxdWFudGl6YXRpb24gbW9kZSBjaGFuZ2UATm90IGltcGxlbWVudGVkIHlldABSZXF1ZXN0ZWQgZmVhdHVyZSB3YXMgb21pdHRlZCBhdCBjb21waWxlIHRpbWUAQXJpdGhtZXRpYyB0YWJsZSAweCUwMnggd2FzIG5vdCBkZWZpbmVkAEJhY2tpbmcgc3RvcmUgbm90IHN1cHBvcnRlZABIdWZmbWFuIHRhYmxlIDB4JTAyeCB3YXMgbm90IGRlZmluZWQASlBFRyBkYXRhc3RyZWFtIGNvbnRhaW5zIG5vIGltYWdlAFF1YW50aXphdGlvbiB0YWJsZSAweCUwMnggd2FzIG5vdCBkZWZpbmVkAE5vdCBhIEpQRUcgZmlsZTogc3RhcnRzIHdpdGggMHglMDJ4IDB4JTAyeABJbnN1ZmZpY2llbnQgbWVtb3J5IChjYXNlICVkKQBDYW5ub3QgcXVhbnRpemUgbW9yZSB0aGFuICVkIGNvbG9yIGNvbXBvbmVudHMAQ2Fubm90IHF1YW50aXplIHRvIGZld2VyIHRoYW4gJWQgY29sb3JzAENhbm5vdCBxdWFudGl6ZSB0byBtb3JlIHRoYW4gJWQgY29sb3JzAEludmFsaWQgSlBFRyBmaWxlIHN0cnVjdHVyZTogJXMgYmVmb3JlIFNPRgBJbnZhbGlkIEpQRUcgZmlsZSBzdHJ1Y3R1cmU6IHR3byBTT0YgbWFya2VycwBJbnZhbGlkIEpQRUcgZmlsZSBzdHJ1Y3R1cmU6IG1pc3NpbmcgU09TIG1hcmtlcgBVbnN1cHBvcnRlZCBKUEVHIHByb2Nlc3M6IFNPRiB0eXBlIDB4JTAyeABJbnZhbGlkIEpQRUcgZmlsZSBzdHJ1Y3R1cmU6IHR3byBTT0kgbWFya2VycwBGYWlsZWQgdG8gY3JlYXRlIHRlbXBvcmFyeSBmaWxlICVzAFJlYWQgZmFpbGVkIG9uIHRlbXBvcmFyeSBmaWxlAFNlZWsgZmFpbGVkIG9uIHRlbXBvcmFyeSBmaWxlAFdyaXRlIGZhaWxlZCBvbiB0ZW1wb3JhcnkgZmlsZSAtLS0gb3V0IG9mIGRpc2sgc3BhY2U/AEFwcGxpY2F0aW9uIHRyYW5zZmVycmVkIHRvbyBmZXcgc2NhbmxpbmVzAFVuc3VwcG9ydGVkIG1hcmtlciB0eXBlIDB4JTAyeABWaXJ0dWFsIGFycmF5IGNvbnRyb2xsZXIgbWVzc2VkIHVwAEltYWdlIHRvbyB3aWRlIGZvciB0aGlzIGltcGxlbWVudGF0aW9uAFJlYWQgZnJvbSBYTVMgZmFpbGVkAFdyaXRlIHRvIFhNUyBmYWlsZWQAQ29weXJpZ2h0IChDKSAyMDE4LCBUaG9tYXMgRy4gTGFuZSwgR3VpZG8gVm9sbGJlZGluZwA5YyAgMTQtSmFuLTIwMTgAQ2F1dGlvbjogcXVhbnRpemF0aW9uIHRhYmxlcyBhcmUgdG9vIGNvYXJzZSBmb3IgYmFzZWxpbmUgSlBFRwBBZG9iZSBBUFAxNCBtYXJrZXI6IHZlcnNpb24gJWQsIGZsYWdzIDB4JTA0eCAweCUwNHgsIHRyYW5zZm9ybSAlZABVbmtub3duIEFQUDAgbWFya2VyIChub3QgSkZJRiksIGxlbmd0aCAldQBVbmtub3duIEFQUDE0IG1hcmtlciAobm90IEFkb2JlKSwgbGVuZ3RoICV1AERlZmluZSBBcml0aG1ldGljIFRhYmxlIDB4JTAyeDogMHglMDJ4AERlZmluZSBIdWZmbWFuIFRhYmxlIDB4JTAyeABEZWZpbmUgUXVhbnRpemF0aW9uIFRhYmxlICVkICBwcmVjaXNpb24gJWQARGVmaW5lIFJlc3RhcnQgSW50ZXJ2YWwgJXUARnJlZWQgRU1TIGhhbmRsZSAldQBPYnRhaW5lZCBFTVMgaGFuZGxlICV1AEVuZCBPZiBJbWFnZQAgICAgICAgICUzZCAlM2QgJTNkICUzZCAlM2QgJTNkICUzZCAlM2QASkZJRiBBUFAwIG1hcmtlcjogdmVyc2lvbiAlZC4lMDJkLCBkZW5zaXR5ICVkeCVkICAlZABXYXJuaW5nOiB0aHVtYm5haWwgaW1hZ2Ugc2l6ZSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCAldQBKRklGIGV4dGVuc2lvbiBtYXJrZXI6IHR5cGUgMHglMDJ4LCBsZW5ndGggJXUAICAgIHdpdGggJWQgeCAlZCB0aHVtYm5haWwgaW1hZ2UATWlzY2VsbGFuZW91cyBtYXJrZXIgMHglMDJ4LCBsZW5ndGggJXUAVW5leHBlY3RlZCBtYXJrZXIgMHglMDJ4ACAgICAgICAgJTR1ICU0dSAlNHUgJTR1ICU0dSAlNHUgJTR1ICU0dQBRdWFudGl6aW5nIHRvICVkID0gJWQqJWQqJWQgY29sb3JzAFF1YW50aXppbmcgdG8gJWQgY29sb3JzAFNlbGVjdGVkICVkIGNvbG9ycyBmb3IgcXVhbnRpemF0aW9uAEF0IG1hcmtlciAweCUwMngsIHJlY292ZXJ5IGFjdGlvbiAlZABSU1QlZABTbW9vdGhpbmcgbm90IHN1cHBvcnRlZCB3aXRoIG5vbnN0YW5kYXJkIHNhbXBsaW5nIHJhdGlvcwBTdGFydCBPZiBGcmFtZSAweCUwMng6IHdpZHRoPSV1LCBoZWlnaHQ9JXUsIGNvbXBvbmVudHM9JWQAICAgIENvbXBvbmVudCAlZDogJWRoeCVkdiBxPSVkAFN0YXJ0IG9mIEltYWdlAFN0YXJ0IE9mIFNjYW46ICVkIGNvbXBvbmVudHMAICAgIENvbXBvbmVudCAlZDogZGM9JWQgYWM9JWQAICBTcz0lZCwgU2U9JWQsIEFoPSVkLCBBbD0lZABDbG9zZWQgdGVtcG9yYXJ5IGZpbGUgJXMAT3BlbmVkIHRlbXBvcmFyeSBmaWxlICVzAEpGSUYgZXh0ZW5zaW9uIG1hcmtlcjogSlBFRy1jb21wcmVzc2VkIHRodW1ibmFpbCBpbWFnZSwgbGVuZ3RoICV1AEpGSUYgZXh0ZW5zaW9uIG1hcmtlcjogcGFsZXR0ZSB0aHVtYm5haWwgaW1hZ2UsIGxlbmd0aCAldQBKRklGIGV4dGVuc2lvbiBtYXJrZXI6IFJHQiB0aHVtYm5haWwgaW1hZ2UsIGxlbmd0aCAldQBVbnJlY29nbml6ZWQgY29tcG9uZW50IElEcyAlZCAlZCAlZCwgYXNzdW1pbmcgWUNiQ3IARnJlZWQgWE1TIGhhbmRsZSAldQBPYnRhaW5lZCBYTVMgaGFuZGxlICV1AFVua25vd24gQWRvYmUgY29sb3IgdHJhbnNmb3JtIGNvZGUgJWQAQ29ycnVwdCBKUEVHIGRhdGE6IGJhZCBhcml0aG1ldGljIGNvZGUASW5jb25zaXN0ZW50IHByb2dyZXNzaW9uIHNlcXVlbmNlIGZvciBjb21wb25lbnQgJWQgY29lZmZpY2llbnQgJWQAQ29ycnVwdCBKUEVHIGRhdGE6ICV1IGV4dHJhbmVvdXMgYnl0ZXMg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ZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAAAASHsAAH9mAAAAAAAAAQAAAJQ/AAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAEh7AADYZgAAAAAAAAEAAACUPwAAAAAAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAASHsAADBnAAAAAAAAAQAAAJQ/AAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAABIewAAjGcAAAAAAAABAAAAlD8AAAAAAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAMR6AADoZwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAADEegAAEGgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAxHoAADhoAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAMR6AABgaAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAADEegAAiGgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAxHoAALBoAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAMR6AADYaAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAADEegAAAGkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAxHoAAChpAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAAMR6AABQaQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAADEegAAeGkAABkSRDsCPyxHFD0zMAobBkZLRTcPSQ6OFwNAHTxpKzYfSi0cASAlKSEIDBUWIi4QOD4LNDEYZHR1di9BCX85ESNDMkKJiosFBCYoJw0qHjWMBxpIkxOUlQBBgNQBC5MOSWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAHJ3YQByd2EAQbziAQsBtABB4+IBCwX//////wBBqOMBC1ktKyAgIDBYMHgAKG51bGwpAAAAAAAAAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABEADwoREREDCgcAAQAJCwsAAAkGCwAACwAGEQAAABEREQBBkeQBCyELAAAAAAAAAAARAAoKERERAAoAAAIACQsAAAAJAAsAAAsAQcvkAQsBDABB1+QBCxUMAAAAAAwAAAAACQwAAAAAAAwAAAwAQYXlAQsBDgBBkeUBCxUNAAAABA0AAAAACQ4AAAAAAA4AAA4AQb/lAQsBEABBy+UBCx4PAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAQYLmAQsOEgAAABISEgAAAAAAAAkAQbPmAQsBCwBBv+YBCxUKAAAAAAoAAAAACQsAAAAAAAsAAAsAQe3mAQsBDABB+eYBC5kFDAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAuAAAAAFh8AABpbmZpbml0eQBuYW4AAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAA/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAAACAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAAAMARAADAEgAAwBMAAMAUAADAFQAAwBYAAMAXAADAGAAAwBkAAMAaAADAGwAAwBwAAMAdAADAHgAAwB8AAMAAAACzAQAAwwIAAMMDAADDBAAAwwUAAMMGAADDBwAAwwgAAMMJAADDCgAAwwsAAMMMAADDDQAA0w4AAMMPAADDAAAMuwEADMMCAAzDAwAMwwQADNN2ZWN0b3IAQaTsAQuRCwIAAAADAAAABQAAAAcAAAALAAAADQAAABEAAAATAAAAFwAAAB0AAAAfAAAAJQAAACkAAAArAAAALwAAADUAAAA7AAAAPQAAAEMAAABHAAAASQAAAE8AAABTAAAAWQAAAGEAAABlAAAAZwAAAGsAAABtAAAAcQAAAH8AAACDAAAAiQAAAIsAAACVAAAAlwAAAJ0AAACjAAAApwAAAK0AAACzAAAAtQAAAL8AAADBAAAAxQAAAMcAAADTAAAAAQAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAeQAAAH8AAACDAAAAiQAAAIsAAACPAAAAlQAAAJcAAACdAAAAowAAAKcAAACpAAAArQAAALMAAAC1AAAAuwAAAL8AAADBAAAAxQAAAMcAAADRAAAAX19uZXh0X3ByaW1lIG92ZXJmbG93AGJhc2ljX3N0cmluZwBzdGQ6OmV4Y2VwdGlvbgAAAAAAAAD4dwAAugAAALsAAAC8AAAAU3Q5ZXhjZXB0aW9uAAAAAMR6AADodwAAAAAAACR4AAALAAAAvQAAAL4AAABTdDExbG9naWNfZXJyb3IA7HoAABR4AAD4dwAAAAAAAFh4AAALAAAAvwAAAL4AAABTdDEybGVuZ3RoX2Vycm9yAAAAAOx6AABEeAAAJHgAAFN0OXR5cGVfaW5mbwAAAADEegAAZHgAAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAAOx6AAB8eAAAdHgAAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAAOx6AACseAAAoHgAAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQAAAOx6AADceAAAoHgAAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FAOx6AAAMeQAAAHkAAE4xMF9fY3h4YWJpdjEyMF9fZnVuY3Rpb25fdHlwZV9pbmZvRQAAAADsegAAPHkAAKB4AABOMTBfX2N4eGFiaXYxMjlfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mb0UAAADsegAAcHkAAAB5AAAAAAAA8HkAAMAAAADBAAAAwgAAAMMAAADEAAAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAOx6AADIeQAAoHgAAHYAAAC0eQAA/HkAAERuAAC0eQAACHoAAGIAAAC0eQAAFHoAAGMAAAC0eQAAIHoAAGgAAAC0eQAALHoAAGEAAAC0eQAAOHoAAHMAAAC0eQAARHoAAHQAAAC0eQAAUHoAAGkAAAC0eQAAXHoAAGoAAAC0eQAAaHoAAGwAAAC0eQAAdHoAAG0AAAC0eQAAgHoAAHgAAAC0eQAAjHoAAHkAAAC0eQAAmHoAAGYAAAC0eQAApHoAAGQAAAC0eQAAsHoAAAAAAADQeAAAwAAAAMUAAADCAAAAwwAAAMYAAADHAAAAyAAAAMkAAAAAAAAANHsAAMAAAADKAAAAwgAAAMMAAADGAAAAywAAAMwAAADNAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAOx6AAAMewAA0HgAAAAAAACQewAAwAAAAM4AAADCAAAAwwAAAMYAAADPAAAA0AAAANEAAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAA7HoAAGh7AADQeAAAAAAAADB5AADAAAAA0gAAAMIAAADDAAAA0wBBuPcBCwkBAAAAAAAAAAUAQcz3AQsBtwBB5PcBCw6xAAAAuAAAADh/AAAABABB/PcBCwEBAEGL+AELBQr/////AEHQ+AELCcB7AAAAAAAABQBB5PgBCwGzAEH8+AELCrEAAACwAAAAQIMAQZT5AQsBAgBBo/kBCwX//////wBBlPsBCwIUfwBBzPsBCwNwhVA=\";\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary(file) {\n      try {\n        if (file == wasmBinaryFile && wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n\n        var binary = tryParseAsDataURI(file);\n\n        if (binary) {\n          return binary;\n        }\n\n        if (readBinary) {\n          return readBinary(file);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch === \"function\" && !isFileURI(wasmBinaryFile)) {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            if (!response[\"ok\"]) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response[\"arrayBuffer\"]();\n          })[\"catch\"](function () {\n            return getBinary(wasmBinaryFile);\n          });\n        } else {\n          if (readAsync) {\n            return new Promise(function (resolve, reject) {\n              readAsync(wasmBinaryFile, function (response) {\n                resolve(new Uint8Array(response));\n              }, reject);\n            });\n          }\n        }\n      }\n\n      return Promise.resolve().then(function () {\n        return getBinary(wasmBinaryFile);\n      });\n    }\n\n    function createWasm() {\n      var info = {\n        \"a\": asmLibraryArg\n      };\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmMemory = Module[\"asm\"][\"X\"];\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        wasmTable = Module[\"asm\"][\"aa\"];\n        addOnInit(Module[\"asm\"][\"Y\"]);\n        removeRunDependency(\"wasm-instantiate\");\n      }\n\n      addRunDependency(\"wasm-instantiate\");\n\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          var result = WebAssembly.instantiate(binary, info);\n          return result;\n        }).then(receiver, function (reason) {\n          err(\"failed to asynchronously prepare wasm: \" + reason);\n          abort(reason);\n        });\n      }\n\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === \"function\" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, {\n            credentials: \"same-origin\"\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiationResult, function (reason) {\n              err(\"wasm streaming compile failed: \" + reason);\n              err(\"falling back to ArrayBuffer instantiation\");\n              return instantiateArrayBuffer(receiveInstantiationResult);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiationResult);\n        }\n      }\n\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n\n      instantiateAsync()[\"catch\"](readyPromiseReject);\n      return {};\n    }\n\n    var tempDouble;\n    var tempI64;\n    var ASM_CONSTS = {\n      32208: function _($0, $1, $2, $3) {\n        if (!arfset[\"frameMalloc\"]) {\n          arfset[\"frameMalloc\"] = {};\n        }\n\n        var frameMalloc = arfset[\"frameMalloc\"];\n        frameMalloc[\"frameIbwpointer\"] = $1;\n        frameMalloc[\"frameimgBWsize\"] = $2;\n        frameMalloc[\"frameFeaturePoints\"] = $3;\n      }\n    };\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == \"function\") {\n          callback(Module);\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            wasmTable.get(func)();\n          } else {\n            wasmTable.get(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var runtimeKeepaliveCounter = 0;\n\n    function keepRuntimeAlive() {\n      return noExitRuntime || runtimeKeepaliveCounter > 0;\n    }\n\n    var ExceptionInfoAttrs = {\n      DESTRUCTOR_OFFSET: 0,\n      REFCOUNT_OFFSET: 4,\n      TYPE_OFFSET: 8,\n      CAUGHT_OFFSET: 12,\n      RETHROWN_OFFSET: 13,\n      SIZE: 16\n    };\n\n    function ___cxa_allocate_exception(size) {\n      return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;\n    }\n\n    function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - ExceptionInfoAttrs.SIZE;\n\n      this.set_type = function (type) {\n        HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2] = type;\n      };\n\n      this.get_type = function () {\n        return HEAP32[this.ptr + ExceptionInfoAttrs.TYPE_OFFSET >> 2];\n      };\n\n      this.set_destructor = function (destructor) {\n        HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2] = destructor;\n      };\n\n      this.get_destructor = function () {\n        return HEAP32[this.ptr + ExceptionInfoAttrs.DESTRUCTOR_OFFSET >> 2];\n      };\n\n      this.set_refcount = function (refcount) {\n        HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = refcount;\n      };\n\n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] = caught;\n      };\n\n      this.get_caught = function () {\n        return HEAP8[this.ptr + ExceptionInfoAttrs.CAUGHT_OFFSET >> 0] != 0;\n      };\n\n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] = rethrown;\n      };\n\n      this.get_rethrown = function () {\n        return HEAP8[this.ptr + ExceptionInfoAttrs.RETHROWN_OFFSET >> 0] != 0;\n      };\n\n      this.init = function (type, destructor) {\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      };\n\n      this.add_ref = function () {\n        var value = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2];\n        HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = value + 1;\n      };\n\n      this.release_ref = function () {\n        var prev = HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2];\n        HEAP32[this.ptr + ExceptionInfoAttrs.REFCOUNT_OFFSET >> 2] = prev - 1;\n        return prev === 1;\n      };\n    }\n\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n\n    function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n\n    function setErrNo(value) {\n      HEAP32[___errno_location() >> 2] = value;\n      return value;\n    }\n\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === \".\") {\n            parts.splice(i, 1);\n          } else if (last === \"..\") {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift(\"..\");\n          }\n        }\n\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === \"/\",\n            trailingSlash = path.substr(-1) === \"/\";\n        path = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join(\"/\");\n\n        if (!path && !isAbsolute) {\n          path = \".\";\n        }\n\n        if (path && trailingSlash) {\n          path += \"/\";\n        }\n\n        return (isAbsolute ? \"/\" : \"\") + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          return \".\";\n        }\n\n        if (dir) {\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function basename(path) {\n        if (path === \"/\") return \"/\";\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf(\"/\");\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join(\"/\"));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + \"/\" + r);\n      }\n    };\n\n    function getRandomDevice() {\n      if ((typeof crypto === \"undefined\" ? \"undefined\" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(crypto)) === \"object\" && typeof crypto[\"getRandomValues\"] === \"function\") {\n        var randomBuffer = new Uint8Array(1);\n        return function () {\n          crypto.getRandomValues(randomBuffer);\n          return randomBuffer[0];\n        };\n      } else if (ENVIRONMENT_IS_NODE) {\n        try {\n          var crypto_module = __webpack_require__(/*! crypto */ \"?deb7\");\n\n          return function () {\n            return crypto_module[\"randomBytes\"](1)[0];\n          };\n        } catch (e) {}\n      }\n\n      return function () {\n        abort(\"randomDevice\");\n      };\n    }\n\n    var PATH_FS = {\n      resolve: function resolve() {\n        var resolvedPath = \"\",\n            resolvedAbsolute = false;\n\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? arguments[i] : FS.cwd();\n\n          if (typeof path !== \"string\") {\n            throw new TypeError(\"Arguments to path.resolve must be strings\");\n          } else if (!path) {\n            return \"\";\n          }\n\n          resolvedPath = path + \"/\" + resolvedPath;\n          resolvedAbsolute = path.charAt(0) === \"/\";\n        }\n\n        resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join(\"/\");\n        return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n      },\n      relative: function relative(from, to) {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n\n        function trim(arr) {\n          var start = 0;\n\n          for (; start < arr.length; start++) {\n            if (arr[start] !== \"\") break;\n          }\n\n          var end = arr.length - 1;\n\n          for (; end >= 0; end--) {\n            if (arr[end] !== \"\") break;\n          }\n\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n\n        var fromParts = trim(from.split(\"/\"));\n        var toParts = trim(to.split(\"/\"));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n\n        var outputParts = [];\n\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push(\"..\");\n        }\n\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join(\"/\");\n      }\n    };\n    var TTY = {\n      ttys: [],\n      init: function init() {},\n      shutdown: function shutdown() {},\n      register: function register(dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function close(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        flush: function flush(stream) {\n          stream.tty.ops.flush(stream.tty);\n        },\n        read: function read(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n\n          var bytesRead = 0;\n\n          for (var i = 0; i < length; i++) {\n            var result;\n\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return bytesRead;\n        },\n        write: function write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function get_char(tty) {\n          if (!tty.input.length) {\n            var result = null;\n\n            if (ENVIRONMENT_IS_NODE) {\n              var BUFSIZE = 256;\n              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);\n              var bytesRead = 0;\n\n              try {\n                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);\n              } catch (e) {\n                if (e.toString().includes(\"EOF\")) bytesRead = 0;else throw e;\n              }\n\n              if (bytesRead > 0) {\n                result = buf.slice(0, bytesRead).toString(\"utf-8\");\n              } else {\n                result = null;\n              }\n            } else if (typeof window != \"undefined\" && typeof window.prompt == \"function\") {\n              result = window.prompt(\"Input: \");\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            } else if (typeof readline == \"function\") {\n              result = readline();\n\n              if (result !== null) {\n                result += \"\\n\";\n              }\n            }\n\n            if (!result) {\n              return null;\n            }\n\n            tty.input = intArrayFromString(result, true);\n          }\n\n          return tty.input.shift();\n        },\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      },\n      default_tty1_ops: {\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        flush: function flush(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n\n    function mmapAlloc(size) {\n      var alignedSize = alignMemory(size, 65536);\n\n      var ptr = _malloc(alignedSize);\n\n      while (size < alignedSize) {\n        HEAP8[ptr + size++] = 0;\n      }\n\n      return ptr;\n    }\n\n    var MEMFS = {\n      ops_table: null,\n      mount: function mount(_mount) {\n        return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n      },\n      createNode: function createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          throw new FS.ErrnoError(63);\n        }\n\n        if (!MEMFS.ops_table) {\n          MEMFS.ops_table = {\n            dir: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                lookup: MEMFS.node_ops.lookup,\n                mknod: MEMFS.node_ops.mknod,\n                rename: MEMFS.node_ops.rename,\n                unlink: MEMFS.node_ops.unlink,\n                rmdir: MEMFS.node_ops.rmdir,\n                readdir: MEMFS.node_ops.readdir,\n                symlink: MEMFS.node_ops.symlink\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek\n              }\n            },\n            file: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: {\n                llseek: MEMFS.stream_ops.llseek,\n                read: MEMFS.stream_ops.read,\n                write: MEMFS.stream_ops.write,\n                allocate: MEMFS.stream_ops.allocate,\n                mmap: MEMFS.stream_ops.mmap,\n                msync: MEMFS.stream_ops.msync\n              }\n            },\n            link: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr,\n                readlink: MEMFS.node_ops.readlink\n              },\n              stream: {}\n            },\n            chrdev: {\n              node: {\n                getattr: MEMFS.node_ops.getattr,\n                setattr: MEMFS.node_ops.setattr\n              },\n              stream: FS.chrdev_stream_ops\n            }\n          };\n        }\n\n        var node = FS.createNode(parent, name, mode, dev);\n\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0;\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n\n        node.timestamp = Date.now();\n\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n\n        return node;\n      },\n      getFileDataAsTypedArray: function getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return;\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity);\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n      },\n      resizeFileStorage: function resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n\n        if (newSize == 0) {\n          node.contents = null;\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize);\n\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n          }\n\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr: function getattr(node) {\n          var attr = {};\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod: function mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function rename(old_node, new_dir, new_name) {\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n          old_node.parent = new_dir;\n        },\n        unlink: function unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir: function rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir: function readdir(node) {\n          var entries = [\".\", \"..\"];\n\n          for (var key in node.contents) {\n            if (!node.contents.hasOwnProperty(key)) {\n              continue;\n            }\n\n            entries.push(key);\n          }\n\n          return entries;\n        },\n        symlink: function symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n\n          if (size > 8 && contents.subarray) {\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          }\n\n          return size;\n        },\n        write: function write(stream, buffer, offset, length, position, canOwn) {\n          if (buffer.buffer === HEAP8.buffer) {\n            canOwn = false;\n          }\n\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n\n          MEMFS.expandFileStorage(node, position + length);\n\n          if (node.contents.subarray && buffer.subarray) {\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i];\n            }\n          }\n\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function llseek(stream, offset, whence) {\n          var position = offset;\n\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n\n          return position;\n        },\n        allocate: function allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function mmap(stream, address, length, position, prot, flags) {\n          if (address !== 0) {\n            throw new FS.ErrnoError(28);\n          }\n\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n\n          if (!(flags & 2) && contents.buffer === buffer) {\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n\n            allocated = true;\n            ptr = mmapAlloc(length);\n\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n\n            HEAP8.set(contents, ptr);\n          }\n\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function msync(stream, buffer, offset, length, mmapFlags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n\n          if (mmapFlags & 2) {\n            return 0;\n          }\n\n          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          return 0;\n        }\n      }\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      trackingDelegate: {},\n      tracking: {\n        openFlags: {\n          READ: 1,\n          WRITE: 2\n        }\n      },\n      ErrnoError: null,\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      lookupPath: function lookupPath(path, opts) {\n        path = PATH_FS.resolve(FS.cwd(), path);\n        opts = opts || {};\n        if (!path) return {\n          path: \"\",\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n\n        for (var key in defaults) {\n          if (opts[key] === undefined) {\n            opts[key] = defaults[key];\n          }\n        }\n\n        if (opts.recurse_count > 8) {\n          throw new FS.ErrnoError(32);\n        }\n\n        var parts = PATH.normalizeArray(path.split(\"/\").filter(function (p) {\n          return !!p;\n        }), false);\n        var current = FS.root;\n        var current_path = \"/\";\n\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n\n          if (islast && opts.parent) {\n            break;\n          }\n\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n\n          if (!islast || opts.follow) {\n            var count = 0;\n\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count\n              });\n              current = lookup.node;\n\n              if (count++ > 40) {\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function getPath(node) {\n        var path;\n\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== \"/\" ? mount + \"/\" + path : mount + path;\n          }\n\n          path = path ? node.name + \"/\" + path : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function hashName(parentid, name) {\n        var hash = 0;\n\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode, parent);\n        }\n\n        var hash = FS.hashName(parent.id, name);\n\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n\n        return FS.lookup(parent, name);\n      },\n      createNode: function createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint: function isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile: function isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagModes: {\n        \"r\": 0,\n        \"r+\": 2,\n        \"w\": 577,\n        \"w+\": 578,\n        \"a\": 1089,\n        \"a+\": 1090\n      },\n      modeStringToFlags: function modeStringToFlags(str) {\n        var flags = FS.flagModes[str];\n\n        if (typeof flags === \"undefined\") {\n          throw new Error(\"Unknown file open mode: \" + str);\n        }\n\n        return flags;\n      },\n      flagsToPermissionString: function flagsToPermissionString(flag) {\n        var perms = [\"r\", \"w\", \"rw\"][flag & 3];\n\n        if (flag & 512) {\n          perms += \"w\";\n        }\n\n        return perms;\n      },\n      nodePermissions: function nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n\n        if (perms.includes(\"r\") && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n          return 2;\n        }\n\n        return 0;\n      },\n      mayLookup: function mayLookup(dir) {\n        var errCode = FS.nodePermissions(dir, \"x\");\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate: function mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n\n        return FS.nodePermissions(dir, \"wx\");\n      },\n      mayDelete: function mayDelete(dir, name, isdir) {\n        var node;\n\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n\n        var errCode = FS.nodePermissions(dir, \"wx\");\n\n        if (errCode) {\n          return errCode;\n        }\n\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n\n        return 0;\n      },\n      mayOpen: function mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n            return 31;\n          }\n        }\n\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function nextfd(fd_start, fd_end) {\n        fd_start = fd_start || 0;\n        fd_end = fd_end || FS.MAX_OPEN_FDS;\n\n        for (var fd = fd_start; fd <= fd_end; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n\n        throw new FS.ErrnoError(33);\n      },\n      getStream: function getStream(fd) {\n        return FS.streams[fd];\n      },\n      createStream: function createStream(stream, fd_start, fd_end) {\n        if (!FS.FSStream) {\n          FS.FSStream = function () {};\n\n          FS.FSStream.prototype = {\n            object: {\n              get: function get() {\n                return this.node;\n              },\n              set: function set(val) {\n                this.node = val;\n              }\n            },\n            isRead: {\n              get: function get() {\n                return (this.flags & 2097155) !== 1;\n              }\n            },\n            isWrite: {\n              get: function get() {\n                return (this.flags & 2097155) !== 0;\n              }\n            },\n            isAppend: {\n              get: function get() {\n                return this.flags & 1024;\n              }\n            }\n          };\n        }\n\n        var newStream = new FS.FSStream();\n\n        for (var p in stream) {\n          newStream[p] = stream[p];\n        }\n\n        stream = newStream;\n        var fd = FS.nextfd(fd_start, fd_end);\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      chrdev_stream_ops: {\n        open: function open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          stream.stream_ops = device.stream_ops;\n\n          if (stream.stream_ops.open) {\n            stream.stream_ops.open(stream);\n          }\n        },\n        llseek: function llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: function major(dev) {\n        return dev >> 8;\n      },\n      minor: function minor(dev) {\n        return dev & 255;\n      },\n      makedev: function makedev(ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function registerDevice(dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function getDevice(dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, m.mounts);\n        }\n\n        return mounts;\n      },\n      syncfs: function syncfs(populate, callback) {\n        if (typeof populate === \"function\") {\n          callback = populate;\n          populate = false;\n        }\n\n        FS.syncFSRequests++;\n\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \" + FS.syncFSRequests + \" FS.syncfs operations in flight at once, probably just doing extra work\");\n        }\n\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n\n            return;\n          }\n\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function mount(type, opts, mountpoint) {\n        var root = mountpoint === \"/\";\n        var pseudo = !mountpoint;\n        var node;\n\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path;\n          node = lookup.node;\n\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          node.mounted = mount;\n\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n\n        return mountRoot;\n      },\n      unmount: function unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n\n          while (current) {\n            var next = current.name_next;\n\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n\n            current = next;\n          }\n        });\n        node.mounted = null;\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n\n        if (!name || name === \".\" || name === \"..\") {\n          throw new FS.ErrnoError(28);\n        }\n\n        var errCode = FS.mayCreate(parent, name);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function create(path, mode) {\n        mode = mode !== undefined ? mode : 438;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function mkdirTree(path, mode) {\n        var dirs = path.split(\"/\");\n        var d = \"\";\n\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += \"/\" + dirs[i];\n\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev: function mkdev(path, mode, dev) {\n        if (typeof dev === \"undefined\") {\n          dev = mode;\n          mode = 438;\n        }\n\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        var lookup, old_dir, new_dir;\n        lookup = FS.lookupPath(old_path, {\n          parent: true\n        });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, {\n          parent: true\n        });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n\n        var old_node = FS.lookupNode(old_dir, old_name);\n        var relative = PATH_FS.relative(old_path, new_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(28);\n        }\n\n        relative = PATH_FS.relative(new_path, old_dirname);\n\n        if (relative.charAt(0) !== \".\") {\n          throw new FS.ErrnoError(55);\n        }\n\n        var new_node;\n\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {}\n\n        if (old_node === new_node) {\n          return;\n        }\n\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, \"w\");\n\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willMovePath\"]) {\n            FS.trackingDelegate[\"willMovePath\"](old_path, new_path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n\n        FS.hashRemoveNode(old_node);\n\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.hashAddNode(old_node);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onMovePath\"]) FS.trackingDelegate[\"onMovePath\"](old_path, new_path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onMovePath']('\" + old_path + \"', '\" + new_path + \"') threw an exception: \" + e.message);\n        }\n      },\n      rmdir: function rmdir(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readdir: function readdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n\n        return node.node_ops.readdir(node);\n      },\n      unlink: function unlink(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n\n        try {\n          if (FS.trackingDelegate[\"willDeletePath\"]) {\n            FS.trackingDelegate[\"willDeletePath\"](path);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['willDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n\n        try {\n          if (FS.trackingDelegate[\"onDeletePath\"]) FS.trackingDelegate[\"onDeletePath\"](path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onDeletePath']('\" + path + \"') threw an exception: \" + e.message);\n        }\n      },\n      readlink: function readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n\n        return node.node_ops.getattr(node);\n      },\n      lstat: function lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod: function chmod(path, mode, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function fchmod(fd, mode) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n\n        FS.chmod(stream.node, mode);\n      },\n      chown: function chown(path, uid, gid, dontFollow) {\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n        });\n      },\n      lchown: function lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function fchown(fd, uid, gid) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var node;\n\n        if (typeof path === \"string\") {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var errCode = FS.nodePermissions(node, \"w\");\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function ftruncate(fd, len) {\n        var stream = FS.getStream(fd);\n\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n\n        FS.truncate(stream.node, len);\n      },\n      utime: function utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function open(path, flags, mode, fd_start, fd_end) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n\n        flags = typeof flags === \"string\" ? FS.modeStringToFlags(flags) : flags;\n        mode = typeof mode === \"undefined\" ? 438 : mode;\n\n        if (flags & 64) {\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n\n        var node;\n\n        if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(path) === \"object\") {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {}\n        }\n\n        var created = false;\n\n        if (flags & 64) {\n          if (node) {\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n\n        if (flags & 512) {\n          FS.truncate(node, 0);\n        }\n\n        flags &= ~(128 | 512 | 131072);\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          ungotten: [],\n          error: false\n        }, fd_start, fd_end);\n\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n\n        if (Module[\"logReadFiles\"] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n            err(\"FS.trackingDelegate error on read file: \" + path);\n          }\n        }\n\n        try {\n          if (FS.trackingDelegate[\"onOpenFile\"]) {\n            var trackingFlags = 0;\n\n            if ((flags & 2097155) !== 1) {\n              trackingFlags |= FS.tracking.openFlags.READ;\n            }\n\n            if ((flags & 2097155) !== 0) {\n              trackingFlags |= FS.tracking.openFlags.WRITE;\n            }\n\n            FS.trackingDelegate[\"onOpenFile\"](path, trackingFlags);\n          }\n        } catch (e) {\n          err(\"FS.trackingDelegate['onOpenFile']('\" + path + \"', flags) threw an exception: \" + e.message);\n        }\n\n        return stream;\n      },\n      close: function close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (stream.getdents) stream.getdents = null;\n\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n\n        stream.fd = null;\n      },\n      isClosed: function isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek: function llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n\n        if (stream.seekable && stream.flags & 1024) {\n          FS.llseek(stream, 0, 2);\n        }\n\n        var seeking = typeof position !== \"undefined\";\n\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n\n        try {\n          if (stream.path && FS.trackingDelegate[\"onWriteToFile\"]) FS.trackingDelegate[\"onWriteToFile\"](stream.path);\n        } catch (e) {\n          err(\"FS.trackingDelegate['onWriteToFile']('\" + stream.path + \"') threw an exception: \" + e.message);\n        }\n\n        return bytesWritten;\n      },\n      allocate: function allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function mmap(stream, address, length, position, prot, flags) {\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n\n        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);\n      },\n      msync: function msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream || !stream.stream_ops.msync) {\n          return 0;\n        }\n\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      munmap: function munmap(stream) {\n        return 0;\n      },\n      ioctl: function ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function readFile(path, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || \"binary\";\n\n        if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n          throw new Error('Invalid encoding type \"' + opts.encoding + '\"');\n        }\n\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n\n        if (opts.encoding === \"utf8\") {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === \"binary\") {\n          ret = buf;\n        }\n\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function writeFile(path, data, opts) {\n        opts = opts || {};\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n\n        if (typeof data === \"string\") {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error(\"Unsupported data type\");\n        }\n\n        FS.close(stream);\n      },\n      cwd: function cwd() {\n        return FS.currentPath;\n      },\n      chdir: function chdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n\n        var errCode = FS.nodePermissions(lookup.node, \"x\");\n\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function createDefaultDirectories() {\n        FS.mkdir(\"/tmp\");\n        FS.mkdir(\"/home\");\n        FS.mkdir(\"/home/web_user\");\n      },\n      createDefaultDevices: function createDefaultDevices() {\n        FS.mkdir(\"/dev\");\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function read() {\n            return 0;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n        FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n        var random_device = getRandomDevice();\n        FS.createDevice(\"/dev\", \"random\", random_device);\n        FS.createDevice(\"/dev\", \"urandom\", random_device);\n        FS.mkdir(\"/dev/shm\");\n        FS.mkdir(\"/dev/shm/tmp\");\n      },\n      createSpecialDirectories: function createSpecialDirectories() {\n        FS.mkdir(\"/proc\");\n        var proc_self = FS.mkdir(\"/proc/self\");\n        FS.mkdir(\"/proc/self/fd\");\n        FS.mount({\n          mount: function mount() {\n            var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n            node.node_ops = {\n              lookup: function lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStream(fd);\n                if (!stream) throw new FS.ErrnoError(8);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: \"fake\"\n                  },\n                  node_ops: {\n                    readlink: function readlink() {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret;\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, \"/proc/self/fd\");\n      },\n      createStandardStreams: function createStandardStreams() {\n        if (Module[\"stdin\"]) {\n          FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n        }\n\n        if (Module[\"stdout\"]) {\n          FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n        } else {\n          FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n        }\n\n        if (Module[\"stderr\"]) {\n          FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n        } else {\n          FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n        }\n\n        var stdin = FS.open(\"/dev/stdin\", 0);\n        var stdout = FS.open(\"/dev/stdout\", 1);\n        var stderr = FS.open(\"/dev/stderr\", 1);\n      },\n      ensureErrnoError: function ensureErrnoError() {\n        if (FS.ErrnoError) return;\n\n        FS.ErrnoError = function ErrnoError(errno, node) {\n          this.node = node;\n\n          this.setErrno = function (errno) {\n            this.errno = errno;\n          };\n\n          this.setErrno(errno);\n          this.message = \"FS error\";\n        };\n\n        FS.ErrnoError.prototype = new Error();\n        FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n        [44].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = \"<generic error, no stack>\";\n        });\n      },\n      staticInit: function staticInit() {\n        FS.ensureErrnoError();\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, \"/\");\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          \"MEMFS\": MEMFS\n        };\n      },\n      init: function init(input, output, error) {\n        FS.init.initialized = true;\n        FS.ensureErrnoError();\n        Module[\"stdin\"] = input || Module[\"stdin\"];\n        Module[\"stdout\"] = output || Module[\"stdout\"];\n        Module[\"stderr\"] = error || Module[\"stderr\"];\n        FS.createStandardStreams();\n      },\n      quit: function quit() {\n        FS.init.initialized = false;\n        var fflush = Module[\"_fflush\"];\n        if (fflush) fflush(0);\n\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n\n          if (!stream) {\n            continue;\n          }\n\n          FS.close(stream);\n        }\n      },\n      getMode: function getMode(canRead, canWrite) {\n        var mode = 0;\n        if (canRead) mode |= 292 | 73;\n        if (canWrite) mode |= 146;\n        return mode;\n      },\n      findObject: function findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n\n        if (ret.exists) {\n          return ret.object;\n        } else {\n          return null;\n        }\n      },\n      analyzePath: function analyzePath(path, dontResolveLastLink) {\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === \"/\";\n        } catch (e) {\n          ret.error = e.errno;\n        }\n\n        return ret;\n      },\n      createPath: function createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent === \"string\" ? parent : FS.getPath(parent);\n        var parts = path.split(\"/\").reverse();\n\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n\n          try {\n            FS.mkdir(current);\n          } catch (e) {}\n\n          parent = current;\n        }\n\n        return current;\n      },\n      createFile: function createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name ? PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name) : parent;\n        var mode = FS.getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n\n        if (data) {\n          if (typeof data === \"string\") {\n            var arr = new Array(data.length);\n\n            for (var i = 0, len = data.length; i < len; ++i) {\n              arr[i] = data.charCodeAt(i);\n            }\n\n            data = arr;\n          }\n\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n\n        return node;\n      },\n      createDevice: function createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent === \"string\" ? parent : FS.getPath(parent), name);\n        var mode = FS.getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        FS.registerDevice(dev, {\n          open: function open(stream) {\n            stream.seekable = false;\n          },\n          close: function close(stream) {\n            if (output && output.buffer && output.buffer.length) {\n              output(10);\n            }\n          },\n          read: function read(stream, buffer, offset, length, pos) {\n            var bytesRead = 0;\n\n            for (var i = 0; i < length; i++) {\n              var result;\n\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return bytesRead;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile: function forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else if (read_) {\n          try {\n            obj.contents = intArrayFromString(read_(obj.url), true);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        } else {\n          throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n        }\n      },\n      createLazyFile: function createLazyFile(parent, name, url, canRead, canWrite) {\n        function LazyUint8Array() {\n          this.lengthKnown = false;\n          this.chunks = [];\n        }\n\n        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n          if (idx > this.length - 1 || idx < 0) {\n            return undefined;\n          }\n\n          var chunkOffset = idx % this.chunkSize;\n          var chunkNum = idx / this.chunkSize | 0;\n          return this.getter(chunkNum)[chunkOffset];\n        };\n\n        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n          this.getter = getter;\n        };\n\n        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"HEAD\", url, false);\n          xhr.send(null);\n          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n          var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n          var header;\n          var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n          var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n          var chunkSize = 1024 * 1024;\n          if (!hasByteServing) chunkSize = datalength;\n\n          var doXHR = function doXHR(from, to) {\n            if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n            if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n            if (typeof Uint8Array != \"undefined\") xhr.responseType = \"arraybuffer\";\n\n            if (xhr.overrideMimeType) {\n              xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n            }\n\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n\n            if (xhr.response !== undefined) {\n              return new Uint8Array(xhr.response || []);\n            } else {\n              return intArrayFromString(xhr.responseText || \"\", true);\n            }\n          };\n\n          var lazyArray = this;\n          lazyArray.setDataGetter(function (chunkNum) {\n            var start = chunkNum * chunkSize;\n            var end = (chunkNum + 1) * chunkSize - 1;\n            end = Math.min(end, datalength - 1);\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") {\n              lazyArray.chunks[chunkNum] = doXHR(start, end);\n            }\n\n            if (typeof lazyArray.chunks[chunkNum] === \"undefined\") throw new Error(\"doXHR failed!\");\n            return lazyArray.chunks[chunkNum];\n          });\n\n          if (usesGzip || !datalength) {\n            chunkSize = datalength = 1;\n            datalength = this.getter(0).length;\n            chunkSize = datalength;\n            out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n          }\n\n          this._length = datalength;\n          this._chunkSize = chunkSize;\n          this.lengthKnown = true;\n        };\n\n        if (typeof XMLHttpRequest !== \"undefined\") {\n          if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n          var lazyArray = new LazyUint8Array();\n          Object.defineProperties(lazyArray, {\n            length: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._length;\n              }\n            },\n            chunkSize: {\n              get: function get() {\n                if (!this.lengthKnown) {\n                  this.cacheLength();\n                }\n\n                return this._chunkSize;\n              }\n            }\n          });\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function get() {\n              return this.contents.length;\n            }\n          }\n        });\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n\n          stream_ops[key] = function forceLoadLazyFile() {\n            FS.forceLoadFile(node);\n            return fn.apply(null, arguments);\n          };\n        });\n\n        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {\n          FS.forceLoadFile(node);\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n\n          if (contents.slice) {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n\n          return size;\n        };\n\n        node.stream_ops = stream_ops;\n        return node;\n      },\n      createPreloadedFile: function createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n        Browser.init();\n        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n        var dep = getUniqueRunDependency(\"cp \" + fullname);\n\n        function processData(byteArray) {\n          function finish(byteArray) {\n            if (preFinish) preFinish();\n\n            if (!dontCreateFile) {\n              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n            }\n\n            if (onload) onload();\n            removeRunDependency(dep);\n          }\n\n          var handled = false;\n          Module[\"preloadPlugins\"].forEach(function (plugin) {\n            if (handled) return;\n\n            if (plugin[\"canHandle\"](fullname)) {\n              plugin[\"handle\"](byteArray, fullname, finish, function () {\n                if (onerror) onerror();\n                removeRunDependency(dep);\n              });\n              handled = true;\n            }\n          });\n          if (!handled) finish(byteArray);\n        }\n\n        addRunDependency(dep);\n\n        if (typeof url == \"string\") {\n          Browser.asyncLoad(url, function (byteArray) {\n            processData(byteArray);\n          }, onerror);\n        } else {\n          processData(url);\n        }\n      },\n      indexedDB: function indexedDB() {\n        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n      },\n      DB_NAME: function DB_NAME() {\n        return \"EM_FS_\" + window.location.pathname;\n      },\n      DB_VERSION: 20,\n      DB_STORE_NAME: \"FILE_DATA\",\n      saveFilesToDB: function saveFilesToDB(paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {\n          out(\"creating db\");\n          var db = openRequest.result;\n          db.createObjectStore(FS.DB_STORE_NAME);\n        };\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n          var transaction = db.transaction([FS.DB_STORE_NAME], \"readwrite\");\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var putRequest = files.put(FS.analyzePath(path).object.contents, path);\n\n            putRequest.onsuccess = function putRequest_onsuccess() {\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            putRequest.onerror = function putRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      },\n      loadFilesFromDB: function loadFilesFromDB(paths, onload, onerror) {\n        onload = onload || function () {};\n\n        onerror = onerror || function () {};\n\n        var indexedDB = FS.indexedDB();\n\n        try {\n          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);\n        } catch (e) {\n          return onerror(e);\n        }\n\n        openRequest.onupgradeneeded = onerror;\n\n        openRequest.onsuccess = function openRequest_onsuccess() {\n          var db = openRequest.result;\n\n          try {\n            var transaction = db.transaction([FS.DB_STORE_NAME], \"readonly\");\n          } catch (e) {\n            onerror(e);\n            return;\n          }\n\n          var files = transaction.objectStore(FS.DB_STORE_NAME);\n          var ok = 0,\n              fail = 0,\n              total = paths.length;\n\n          function finish() {\n            if (fail == 0) onload();else onerror();\n          }\n\n          paths.forEach(function (path) {\n            var getRequest = files.get(path);\n\n            getRequest.onsuccess = function getRequest_onsuccess() {\n              if (FS.analyzePath(path).exists) {\n                FS.unlink(path);\n              }\n\n              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);\n              ok++;\n              if (ok + fail == total) finish();\n            };\n\n            getRequest.onerror = function getRequest_onerror() {\n              fail++;\n              if (ok + fail == total) finish();\n            };\n          });\n          transaction.onerror = onerror;\n        };\n\n        openRequest.onerror = onerror;\n      }\n    };\n    var SYSCALLS = {\n      mappings: {},\n      DEFAULT_POLLMASK: 5,\n      umask: 511,\n      calculateAt: function calculateAt(dirfd, path, allowEmpty) {\n        if (path[0] === \"/\") {\n          return path;\n        }\n\n        var dir;\n\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = FS.getStream(dirfd);\n          if (!dirstream) throw new FS.ErrnoError(8);\n          dir = dirstream.path;\n        }\n\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n          }\n\n          return dir;\n        }\n\n        return PATH.join2(dir, path);\n      },\n      doStat: function doStat(func, path, buf) {\n        try {\n          var stat = func(path);\n        } catch (e) {\n          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n            return -54;\n          }\n\n          throw e;\n        }\n\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = 0;\n        HEAP32[buf + 8 >> 2] = stat.ino;\n        HEAP32[buf + 12 >> 2] = stat.mode;\n        HEAP32[buf + 16 >> 2] = stat.nlink;\n        HEAP32[buf + 20 >> 2] = stat.uid;\n        HEAP32[buf + 24 >> 2] = stat.gid;\n        HEAP32[buf + 28 >> 2] = stat.rdev;\n        HEAP32[buf + 32 >> 2] = 0;\n        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAP32[buf + 48 >> 2] = 4096;\n        HEAP32[buf + 52 >> 2] = stat.blocks;\n        HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;\n        HEAP32[buf + 60 >> 2] = 0;\n        HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;\n        HEAP32[buf + 68 >> 2] = 0;\n        HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;\n        HEAP32[buf + 76 >> 2] = 0;\n        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync: function doMsync(addr, stream, len, flags, offset) {\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      doMkdir: function doMkdir(path, mode) {\n        path = PATH.normalize(path);\n        if (path[path.length - 1] === \"/\") path = path.substr(0, path.length - 1);\n        FS.mkdir(path, mode, 0);\n        return 0;\n      },\n      doMknod: function doMknod(path, mode, dev) {\n        switch (mode & 61440) {\n          case 32768:\n          case 8192:\n          case 24576:\n          case 4096:\n          case 49152:\n            break;\n\n          default:\n            return -28;\n        }\n\n        FS.mknod(path, mode, dev);\n        return 0;\n      },\n      doReadlink: function doReadlink(path, buf, bufsize) {\n        if (bufsize <= 0) return -28;\n        var ret = FS.readlink(path);\n        var len = Math.min(bufsize, lengthBytesUTF8(ret));\n        var endChar = HEAP8[buf + len];\n        stringToUTF8(ret, buf, bufsize + 1);\n        HEAP8[buf + len] = endChar;\n        return len;\n      },\n      doAccess: function doAccess(path, amode) {\n        if (amode & ~7) {\n          return -28;\n        }\n\n        var node;\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        node = lookup.node;\n\n        if (!node) {\n          return -44;\n        }\n\n        var perms = \"\";\n        if (amode & 4) perms += \"r\";\n        if (amode & 2) perms += \"w\";\n        if (amode & 1) perms += \"x\";\n\n        if (perms && FS.nodePermissions(node, perms)) {\n          return -2;\n        }\n\n        return 0;\n      },\n      doDup: function doDup(path, flags, suggestFD) {\n        var suggest = FS.getStream(suggestFD);\n        if (suggest) FS.close(suggest);\n        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;\n      },\n      doReadv: function doReadv(stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.read(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n          if (curr < len) break;\n        }\n\n        return ret;\n      },\n      doWritev: function doWritev(stream, iov, iovcnt, offset) {\n        var ret = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n          var curr = FS.write(stream, HEAP8, ptr, len, offset);\n          if (curr < 0) return -1;\n          ret += curr;\n        }\n\n        return ret;\n      },\n      varargs: undefined,\n      get: function get() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      getStreamFromFD: function getStreamFromFD(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) throw new FS.ErrnoError(8);\n        return stream;\n      },\n      get64: function get64(low, high) {\n        return low;\n      }\n    };\n\n    function ___sys_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n\n        switch (cmd) {\n          case 0:\n            {\n              var arg = SYSCALLS.get();\n\n              if (arg < 0) {\n                return -28;\n              }\n\n              var newStream;\n              newStream = FS.open(stream.path, stream.flags, 0, arg);\n              return newStream.fd;\n            }\n\n          case 1:\n          case 2:\n            return 0;\n\n          case 3:\n            return stream.flags;\n\n          case 4:\n            {\n              var arg = SYSCALLS.get();\n              stream.flags |= arg;\n              return 0;\n            }\n\n          case 12:\n            {\n              var arg = SYSCALLS.get();\n              var offset = 0;\n              HEAP16[arg + offset >> 1] = 2;\n              return 0;\n            }\n\n          case 13:\n          case 14:\n            return 0;\n\n          case 16:\n          case 8:\n            return -28;\n\n          case 9:\n            setErrNo(28);\n            return -1;\n\n          default:\n            {\n              return -28;\n            }\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___sys_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n\n        switch (op) {\n          case 21509:\n          case 21505:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n\n          case 21510:\n          case 21511:\n          case 21512:\n          case 21506:\n          case 21507:\n          case 21508:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n\n          case 21519:\n            {\n              if (!stream.tty) return -59;\n              var argp = SYSCALLS.get();\n              HEAP32[argp >> 2] = 0;\n              return 0;\n            }\n\n          case 21520:\n            {\n              if (!stream.tty) return -59;\n              return -28;\n            }\n\n          case 21531:\n            {\n              var argp = SYSCALLS.get();\n              return FS.ioctl(stream, op, argp);\n            }\n\n          case 21523:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n\n          case 21524:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n\n          default:\n            abort(\"bad ioctl syscall \" + op);\n        }\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___sys_open(path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        var pathname = SYSCALLS.getStr(path);\n        var mode = varargs ? SYSCALLS.get() : 0;\n        var stream = FS.open(pathname, flags, mode);\n        return stream.fd;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    var tupleRegistrations = {};\n\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      } else {\n        return name;\n      }\n    }\n\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\"body\", \"return function \" + name + \"() {\\n\" + '    \"use strict\";' + \"    return body.apply(this, arguments);\\n\" + \"};\\n\")(body);\n    }\n\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n\n        if (stack !== undefined) {\n          this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n\n      return errorClass;\n    }\n\n    var InternalError = undefined;\n\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n\n    function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n\n    function __embind_finalize_value_array(rawTupleType) {\n      var reg = tupleRegistrations[rawTupleType];\n      delete tupleRegistrations[rawTupleType];\n      var elements = reg.elements;\n      var elementsLength = elements.length;\n      var elementTypes = elements.map(function (elt) {\n        return elt.getterReturnType;\n      }).concat(elements.map(function (elt) {\n        return elt.setterArgumentType;\n      }));\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      whenDependentTypesAreResolved([rawTupleType], elementTypes, function (elementTypes) {\n        elements.forEach(function (elt, i) {\n          var getterReturnType = elementTypes[i];\n          var getter = elt.getter;\n          var getterContext = elt.getterContext;\n          var setterArgumentType = elementTypes[i + elementsLength];\n          var setter = elt.setter;\n          var setterContext = elt.setterContext;\n\n          elt.read = function (ptr) {\n            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n          };\n\n          elt.write = function (ptr, o) {\n            var destructors = [];\n            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n            runDestructors(destructors);\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = new Array(elementsLength);\n\n            for (var i = 0; i < elementsLength; ++i) {\n              rv[i] = elements[i].read(ptr);\n            }\n\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            if (elementsLength !== o.length) {\n              throw new TypeError(\"Incorrect number of tuple elements for \" + reg.name + \": expected=\" + elementsLength + \", actual=\" + o.length);\n            }\n\n            var ptr = rawConstructor();\n\n            for (var i = 0; i < elementsLength; ++i) {\n              elements[i].write(ptr, o[i]);\n            }\n\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n\n    var structRegistrations = {};\n\n    function __embind_finalize_value_object(structType) {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords.map(function (field) {\n        return field.getterReturnType;\n      }).concat(fieldRecords.map(function (field) {\n        return field.setterArgumentType;\n      }));\n      whenDependentTypesAreResolved([structType], fieldTypes, function (fieldTypes) {\n        var fields = {};\n        fieldRecords.forEach(function (field, i) {\n          var fieldName = field.fieldName;\n          var getterReturnType = fieldTypes[i];\n          var getter = field.getter;\n          var getterContext = field.getterContext;\n          var setterArgumentType = fieldTypes[i + fieldRecords.length];\n          var setter = field.setter;\n          var setterContext = field.setterContext;\n          fields[fieldName] = {\n            read: function read(ptr) {\n              return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n            },\n            write: function write(ptr, o) {\n              var destructors = [];\n              setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n              runDestructors(destructors);\n            }\n          };\n        });\n        return [{\n          name: reg.name,\n          \"fromWireType\": function fromWireType(ptr) {\n            var rv = {};\n\n            for (var i in fields) {\n              rv[i] = fields[i].read(ptr);\n            }\n\n            rawDestructor(ptr);\n            return rv;\n          },\n          \"toWireType\": function toWireType(destructors, o) {\n            for (var fieldName in fields) {\n              if (!(fieldName in o)) {\n                throw new TypeError('Missing field:  \"' + fieldName + '\"');\n              }\n            }\n\n            var ptr = rawConstructor();\n\n            for (fieldName in fields) {\n              fields[fieldName].write(ptr, o[fieldName]);\n            }\n\n            if (destructors !== null) {\n              destructors.push(rawDestructor, ptr);\n            }\n\n            return ptr;\n          },\n          \"argPackAdvance\": 8,\n          \"readValueFromPointer\": simpleReadValueFromPointer,\n          destructorFunction: rawDestructor\n        }];\n      });\n    }\n\n    function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {}\n\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n\n        case 2:\n          return 1;\n\n        case 4:\n          return 2;\n\n        case 8:\n          return 3;\n\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n\n      embind_charCodes = codes;\n    }\n\n    var embind_charCodes = undefined;\n\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n\n      return ret;\n    }\n\n    var BindingError = undefined;\n\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n      }\n\n      var name = registeredInstance.name;\n\n      if (!rawType) {\n        throwBindingError('type \"' + name + '\" must have a positive integer typeid pointer');\n      }\n\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          cb();\n        });\n      }\n    }\n\n    function __embind_register_bool(rawType, name, size, trueValue, falseValue) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(wt) {\n          return !!wt;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": function readValueFromPointer(pointer) {\n          var heap;\n\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null\n      });\n    }\n\n    function ClassHandle_isAliasOf(other) {\n      if (!(this instanceof ClassHandle)) {\n        return false;\n      }\n\n      if (!(other instanceof ClassHandle)) {\n        return false;\n      }\n\n      var leftClass = this.$$.ptrType.registeredClass;\n      var left = this.$$.ptr;\n      var rightClass = other.$$.ptrType.registeredClass;\n      var right = other.$$.ptr;\n\n      while (leftClass.baseClass) {\n        left = leftClass.upcast(left);\n        leftClass = leftClass.baseClass;\n      }\n\n      while (rightClass.baseClass) {\n        right = rightClass.upcast(right);\n        rightClass = rightClass.baseClass;\n      }\n\n      return leftClass === rightClass && left === right;\n    }\n\n    function shallowCopyInternalPointer(o) {\n      return {\n        count: o.count,\n        deleteScheduled: o.deleteScheduled,\n        preservePointerOnDelete: o.preservePointerOnDelete,\n        ptr: o.ptr,\n        ptrType: o.ptrType,\n        smartPtr: o.smartPtr,\n        smartPtrType: o.smartPtrType\n      };\n    }\n\n    function throwInstanceAlreadyDeleted(obj) {\n      function getInstanceTypeName(handle) {\n        return handle.$$.ptrType.registeredClass.name;\n      }\n\n      throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n    }\n\n    var finalizationGroup = false;\n\n    function detachFinalizer(handle) {}\n\n    function runDestructor($$) {\n      if ($$.smartPtr) {\n        $$.smartPtrType.rawDestructor($$.smartPtr);\n      } else {\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\n      }\n    }\n\n    function releaseClassHandle($$) {\n      $$.count.value -= 1;\n      var toDelete = 0 === $$.count.value;\n\n      if (toDelete) {\n        runDestructor($$);\n      }\n    }\n\n    function attachFinalizer(handle) {\n      if (\"undefined\" === typeof FinalizationGroup) {\n        attachFinalizer = function attachFinalizer(handle) {\n          return handle;\n        };\n\n        return handle;\n      }\n\n      finalizationGroup = new FinalizationGroup(function (iter) {\n        for (var result = iter.next(); !result.done; result = iter.next()) {\n          var $$ = result.value;\n\n          if (!$$.ptr) {\n            console.warn(\"object already deleted: \" + $$.ptr);\n          } else {\n            releaseClassHandle($$);\n          }\n        }\n      });\n\n      attachFinalizer = function attachFinalizer(handle) {\n        finalizationGroup.register(handle, handle.$$, handle.$$);\n        return handle;\n      };\n\n      detachFinalizer = function detachFinalizer(handle) {\n        finalizationGroup.unregister(handle.$$);\n      };\n\n      return attachFinalizer(handle);\n    }\n\n    function ClassHandle_clone() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.preservePointerOnDelete) {\n        this.$$.count.value += 1;\n        return this;\n      } else {\n        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n          $$: {\n            value: shallowCopyInternalPointer(this.$$)\n          }\n        }));\n        clone.$$.count.value += 1;\n        clone.$$.deleteScheduled = false;\n        return clone;\n      }\n    }\n\n    function ClassHandle_delete() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n\n      detachFinalizer(this);\n      releaseClassHandle(this.$$);\n\n      if (!this.$$.preservePointerOnDelete) {\n        this.$$.smartPtr = undefined;\n        this.$$.ptr = undefined;\n      }\n    }\n\n    function ClassHandle_isDeleted() {\n      return !this.$$.ptr;\n    }\n\n    var delayFunction = undefined;\n    var deletionQueue = [];\n\n    function flushPendingDeletes() {\n      while (deletionQueue.length) {\n        var obj = deletionQueue.pop();\n        obj.$$.deleteScheduled = false;\n        obj[\"delete\"]();\n      }\n    }\n\n    function ClassHandle_deleteLater() {\n      if (!this.$$.ptr) {\n        throwInstanceAlreadyDeleted(this);\n      }\n\n      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n        throwBindingError(\"Object already scheduled for deletion\");\n      }\n\n      deletionQueue.push(this);\n\n      if (deletionQueue.length === 1 && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n\n      this.$$.deleteScheduled = true;\n      return this;\n    }\n\n    function init_ClassHandle() {\n      ClassHandle.prototype[\"isAliasOf\"] = ClassHandle_isAliasOf;\n      ClassHandle.prototype[\"clone\"] = ClassHandle_clone;\n      ClassHandle.prototype[\"delete\"] = ClassHandle_delete;\n      ClassHandle.prototype[\"isDeleted\"] = ClassHandle_isDeleted;\n      ClassHandle.prototype[\"deleteLater\"] = ClassHandle_deleteLater;\n    }\n\n    function ClassHandle() {}\n\n    var registeredPointers = {};\n\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n\n        proto[methodName] = function () {\n          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n            throwBindingError(\"Function '\" + humanName + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + proto[methodName].overloadTable + \")!\");\n          }\n\n          return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n        };\n\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n\n        ensureOverloadTable(Module, name, name);\n\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\" + numArguments + \")!\");\n        }\n\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n\n    function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n      this.name = name;\n      this.constructor = constructor;\n      this.instancePrototype = instancePrototype;\n      this.rawDestructor = rawDestructor;\n      this.baseClass = baseClass;\n      this.getActualType = getActualType;\n      this.upcast = upcast;\n      this.downcast = downcast;\n      this.pureVirtualFunctions = [];\n    }\n\n    function upcastPointer(ptr, ptrClass, desiredClass) {\n      while (ptrClass !== desiredClass) {\n        if (!ptrClass.upcast) {\n          throwBindingError(\"Expected null or instance of \" + desiredClass.name + \", got an instance of \" + ptrClass.name);\n        }\n\n        ptr = ptrClass.upcast(ptr);\n        ptrClass = ptrClass.baseClass;\n      }\n\n      return ptr;\n    }\n\n    function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n\n        return 0;\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    function genericPointerToWireType(destructors, handle) {\n      var ptr;\n\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n\n        if (this.isSmartPointer) {\n          ptr = this.rawConstructor();\n\n          if (destructors !== null) {\n            destructors.push(this.rawDestructor, ptr);\n          }\n\n          return ptr;\n        } else {\n          return 0;\n        }\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n\n      if (!this.isConst && handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n\n      if (this.isSmartPointer) {\n        if (undefined === handle.$$.smartPtr) {\n          throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n        }\n\n        switch (this.sharingPolicy) {\n          case 0:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              throwBindingError(\"Cannot convert argument of type \" + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + \" to parameter type \" + this.name);\n            }\n\n            break;\n\n          case 1:\n            ptr = handle.$$.smartPtr;\n            break;\n\n          case 2:\n            if (handle.$$.smartPtrType === this) {\n              ptr = handle.$$.smartPtr;\n            } else {\n              var clonedHandle = handle[\"clone\"]();\n              ptr = this.rawShare(ptr, __emval_register(function () {\n                clonedHandle[\"delete\"]();\n              }));\n\n              if (destructors !== null) {\n                destructors.push(this.rawDestructor, ptr);\n              }\n            }\n\n            break;\n\n          default:\n            throwBindingError(\"Unsupporting sharing policy\");\n        }\n      }\n\n      return ptr;\n    }\n\n    function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n      if (handle === null) {\n        if (this.isReference) {\n          throwBindingError(\"null is not a valid \" + this.name);\n        }\n\n        return 0;\n      }\n\n      if (!handle.$$) {\n        throwBindingError('Cannot pass \"' + _embind_repr(handle) + '\" as a ' + this.name);\n      }\n\n      if (!handle.$$.ptr) {\n        throwBindingError(\"Cannot pass deleted object as a pointer of type \" + this.name);\n      }\n\n      if (handle.$$.ptrType.isConst) {\n        throwBindingError(\"Cannot convert argument of type \" + handle.$$.ptrType.name + \" to parameter type \" + this.name);\n      }\n\n      var handleClass = handle.$$.ptrType.registeredClass;\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n      return ptr;\n    }\n\n    function RegisteredPointer_getPointee(ptr) {\n      if (this.rawGetPointee) {\n        ptr = this.rawGetPointee(ptr);\n      }\n\n      return ptr;\n    }\n\n    function RegisteredPointer_destructor(ptr) {\n      if (this.rawDestructor) {\n        this.rawDestructor(ptr);\n      }\n    }\n\n    function RegisteredPointer_deleteObject(handle) {\n      if (handle !== null) {\n        handle[\"delete\"]();\n      }\n    }\n\n    function downcastPointer(ptr, ptrClass, desiredClass) {\n      if (ptrClass === desiredClass) {\n        return ptr;\n      }\n\n      if (undefined === desiredClass.baseClass) {\n        return null;\n      }\n\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n\n      if (rv === null) {\n        return null;\n      }\n\n      return desiredClass.downcast(rv);\n    }\n\n    function getInheritedInstanceCount() {\n      return Object.keys(registeredInstances).length;\n    }\n\n    function getLiveInheritedInstances() {\n      var rv = [];\n\n      for (var k in registeredInstances) {\n        if (registeredInstances.hasOwnProperty(k)) {\n          rv.push(registeredInstances[k]);\n        }\n      }\n\n      return rv;\n    }\n\n    function setDelayFunction(fn) {\n      delayFunction = fn;\n\n      if (deletionQueue.length && delayFunction) {\n        delayFunction(flushPendingDeletes);\n      }\n    }\n\n    function init_embind() {\n      Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n      Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n      Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n      Module[\"setDelayFunction\"] = setDelayFunction;\n    }\n\n    var registeredInstances = {};\n\n    function getBasestPointer(class_, ptr) {\n      if (ptr === undefined) {\n        throwBindingError(\"ptr should not be undefined\");\n      }\n\n      while (class_.baseClass) {\n        ptr = class_.upcast(ptr);\n        class_ = class_.baseClass;\n      }\n\n      return ptr;\n    }\n\n    function getInheritedInstance(class_, ptr) {\n      ptr = getBasestPointer(class_, ptr);\n      return registeredInstances[ptr];\n    }\n\n    function makeClassHandle(prototype, record) {\n      if (!record.ptrType || !record.ptr) {\n        throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n      }\n\n      var hasSmartPtrType = !!record.smartPtrType;\n      var hasSmartPtr = !!record.smartPtr;\n\n      if (hasSmartPtrType !== hasSmartPtr) {\n        throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n      }\n\n      record.count = {\n        value: 1\n      };\n      return attachFinalizer(Object.create(prototype, {\n        $$: {\n          value: record\n        }\n      }));\n    }\n\n    function RegisteredPointer_fromWireType(ptr) {\n      var rawPointer = this.getPointee(ptr);\n\n      if (!rawPointer) {\n        this.destructor(ptr);\n        return null;\n      }\n\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n\n      if (undefined !== registeredInstance) {\n        if (0 === registeredInstance.$$.count.value) {\n          registeredInstance.$$.ptr = rawPointer;\n          registeredInstance.$$.smartPtr = ptr;\n          return registeredInstance[\"clone\"]();\n        } else {\n          var rv = registeredInstance[\"clone\"]();\n          this.destructor(ptr);\n          return rv;\n        }\n      }\n\n      function makeDefaultHandle() {\n        if (this.isSmartPointer) {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this.pointeeType,\n            ptr: rawPointer,\n            smartPtrType: this,\n            smartPtr: ptr\n          });\n        } else {\n          return makeClassHandle(this.registeredClass.instancePrototype, {\n            ptrType: this,\n            ptr: ptr\n          });\n        }\n      }\n\n      var actualType = this.registeredClass.getActualType(rawPointer);\n      var registeredPointerRecord = registeredPointers[actualType];\n\n      if (!registeredPointerRecord) {\n        return makeDefaultHandle.call(this);\n      }\n\n      var toType;\n\n      if (this.isConst) {\n        toType = registeredPointerRecord.constPointerType;\n      } else {\n        toType = registeredPointerRecord.pointerType;\n      }\n\n      var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n\n      if (dp === null) {\n        return makeDefaultHandle.call(this);\n      }\n\n      if (this.isSmartPointer) {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp,\n          smartPtrType: this,\n          smartPtr: ptr\n        });\n      } else {\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\n          ptrType: toType,\n          ptr: dp\n        });\n      }\n    }\n\n    function init_RegisteredPointer() {\n      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;\n      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;\n      RegisteredPointer.prototype[\"argPackAdvance\"] = 8;\n      RegisteredPointer.prototype[\"readValueFromPointer\"] = simpleReadValueFromPointer;\n      RegisteredPointer.prototype[\"deleteObject\"] = RegisteredPointer_deleteObject;\n      RegisteredPointer.prototype[\"fromWireType\"] = RegisteredPointer_fromWireType;\n    }\n\n    function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n      this.name = name;\n      this.registeredClass = registeredClass;\n      this.isReference = isReference;\n      this.isConst = isConst;\n      this.isSmartPointer = isSmartPointer;\n      this.pointeeType = pointeeType;\n      this.sharingPolicy = sharingPolicy;\n      this.rawGetPointee = rawGetPointee;\n      this.rawConstructor = rawConstructor;\n      this.rawShare = rawShare;\n      this.rawDestructor = rawDestructor;\n\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\n        if (isConst) {\n          this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        } else {\n          this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n          this.destructorFunction = null;\n        }\n      } else {\n        this[\"toWireType\"] = genericPointerToWireType;\n      }\n    }\n\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n\n    function dynCallLegacy(sig, ptr, args) {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n\n      return wasmTable.get(ptr).apply(null, args);\n    }\n\n    function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function () {\n        argCache.length = arguments.length;\n\n        for (var i = 0; i < arguments.length; i++) {\n          argCache[i] = arguments[i];\n        }\n\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n\n        return wasmTable.get(rawFunction);\n      }\n\n      var fp = makeDynCaller();\n\n      if (typeof fp !== \"function\") {\n        throwBindingError(\"unknown function pointer with signature \" + signature + \": \" + rawFunction);\n      }\n\n      return fp;\n    }\n\n    var UnboundTypeError = undefined;\n\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n\n      var rv = readLatin1String(ptr);\n\n      _free(ptr);\n\n      return rv;\n    }\n\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n\n        if (registeredTypes[type]) {\n          return;\n        }\n\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n\n      types.forEach(visit);\n      throw new UnboundTypeError(message + \": \" + unboundTypes.map(getTypeName).join([\", \"]));\n    }\n\n    function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {\n      name = readLatin1String(name);\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n\n      if (upcast) {\n        upcast = embind__requireFunction(upcastSignature, upcast);\n      }\n\n      if (downcast) {\n        downcast = embind__requireFunction(downcastSignature, downcast);\n      }\n\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n      var legalFunctionName = makeLegalFunctionName(name);\n      exposePublicSymbol(legalFunctionName, function () {\n        throwUnboundTypeError(\"Cannot construct \" + name + \" due to unbound types\", [baseClassRawType]);\n      });\n      whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {\n        base = base[0];\n        var baseClass;\n        var basePrototype;\n\n        if (baseClassRawType) {\n          baseClass = base.registeredClass;\n          basePrototype = baseClass.instancePrototype;\n        } else {\n          basePrototype = ClassHandle.prototype;\n        }\n\n        var constructor = createNamedFunction(legalFunctionName, function () {\n          if (Object.getPrototypeOf(this) !== instancePrototype) {\n            throw new BindingError(\"Use 'new' to construct \" + name);\n          }\n\n          if (undefined === registeredClass.constructor_body) {\n            throw new BindingError(name + \" has no accessible constructor\");\n          }\n\n          var body = registeredClass.constructor_body[arguments.length];\n\n          if (undefined === body) {\n            throw new BindingError(\"Tried to invoke ctor of \" + name + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(registeredClass.constructor_body).toString() + \") parameters instead!\");\n          }\n\n          return body.apply(this, arguments);\n        });\n        var instancePrototype = Object.create(basePrototype, {\n          constructor: {\n            value: constructor\n          }\n        });\n        constructor.prototype = instancePrototype;\n        var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n        var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n        var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n        var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n        registeredPointers[rawType] = {\n          pointerType: pointerConverter,\n          constPointerType: constPointerConverter\n        };\n        replacePublicSymbol(legalFunctionName, constructor);\n        return [referenceConverter, pointerConverter, constPointerConverter];\n      });\n    }\n\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n\n      return array;\n    }\n\n    function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {\n      assert(argCount > 0);\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      invoker = embind__requireFunction(invokerSignature, invoker);\n      var args = [rawConstructor];\n      var destructors = [];\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = \"constructor \" + classType.name;\n\n        if (undefined === classType.registeredClass.constructor_body) {\n          classType.registeredClass.constructor_body = [];\n        }\n\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n          throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\" + (argCount - 1) + \") for class '\" + classType.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n        }\n\n        classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {\n          throwUnboundTypeError(\"Cannot construct \" + classType.name + \" due to unbound types\", rawArgTypes);\n        };\n\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {\n            if (arguments.length !== argCount - 1) {\n              throwBindingError(humanName + \" called with \" + arguments.length + \" arguments, expected \" + (argCount - 1));\n            }\n\n            destructors.length = 0;\n            args.length = argCount;\n\n            for (var i = 1; i < argCount; ++i) {\n              args[i] = argTypes[i][\"toWireType\"](destructors, arguments[i - 1]);\n            }\n\n            var ptr = invoker.apply(null, args);\n            runDestructors(destructors);\n            return argTypes[0][\"fromWireType\"](ptr);\n          };\n\n          return [];\n        });\n        return [];\n      });\n    }\n\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\"new_ called with constructor type \" + (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(constructor) + \" which is not a function\");\n      }\n\n      var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function () {});\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n\n    function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {\n      var argCount = argTypes.length;\n\n      if (argCount < 2) {\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n      }\n\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n\n      var invokerFnBody = \"return function \" + makeLegalFunctionName(humanName) + \"(\" + argsList + \") {\\n\" + \"if (arguments.length !== \" + (argCount - 2) + \") {\\n\" + \"throwBindingError('function \" + humanName + \" called with ' + arguments.length + ' arguments, expected \" + (argCount - 2) + \" args!');\\n\" + \"}\\n\";\n\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\n      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\n\n      if (isClassMethodFunc) {\n        invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n\n      if (isClassMethodFunc) {\n        argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n\n      invokerFnBody += (returns ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n\n      if (returns) {\n        invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {}\n\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n\n    function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      methodName = readLatin1String(methodName);\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n      whenDependentTypesAreResolved([], [rawClassType], function (classType) {\n        classType = classType[0];\n        var humanName = classType.name + \".\" + methodName;\n\n        if (isPureVirtual) {\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\n        }\n\n        function unboundTypesHandler() {\n          throwUnboundTypeError(\"Cannot call \" + humanName + \" due to unbound types\", rawArgTypes);\n        }\n\n        var proto = classType.registeredClass.instancePrototype;\n        var method = proto[methodName];\n\n        if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n          unboundTypesHandler.argCount = argCount - 2;\n          unboundTypesHandler.className = classType.name;\n          proto[methodName] = unboundTypesHandler;\n        } else {\n          ensureOverloadTable(proto, methodName, humanName);\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n        }\n\n        whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);\n\n          if (undefined === proto[methodName].overloadTable) {\n            memberFunction.argCount = argCount - 2;\n            proto[methodName] = memberFunction;\n          } else {\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\n          }\n\n          return [];\n        });\n        return [];\n      });\n    }\n\n    var emval_free_list = [];\n    var emval_handle_array = [{}, {\n      value: undefined\n    }, {\n      value: null\n    }, {\n      value: true\n    }, {\n      value: false\n    }];\n\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n\n    function count_emval_handles() {\n      var count = 0;\n\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n\n      return count;\n    }\n\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n\n      return null;\n    }\n\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n\n    function __emval_register(value) {\n      switch (value) {\n        case undefined:\n          {\n            return 1;\n          }\n\n        case null:\n          {\n            return 2;\n          }\n\n        case true:\n          {\n            return 3;\n          }\n\n        case false:\n          {\n            return 4;\n          }\n\n        default:\n          {\n            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;\n            emval_handle_array[handle] = {\n              refcount: 1,\n              value: value\n            };\n            return handle;\n          }\n      }\n    }\n\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(handle) {\n          var rv = emval_handle_array[handle].value;\n\n          __emval_decref(handle);\n\n          return rv;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          return __emval_register(value);\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: null\n      });\n    }\n\n    function _embind_repr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n\n      var t = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(v);\n\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n\n        case 3:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          return value;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n\n          return value;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": floatReadValueFromPointer(name, shift),\n        destructorFunction: null\n      });\n    }\n\n    function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(name, function () {\n        throwUnboundTypeError(\"Cannot call \" + name + \" due to unbound types\", argTypes);\n      }, argCount - 1);\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);\n        return [];\n      });\n    }\n\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed ? function readS8FromPointer(pointer) {\n            return HEAP8[pointer];\n          } : function readU8FromPointer(pointer) {\n            return HEAPU8[pointer];\n          };\n\n        case 1:\n          return signed ? function readS16FromPointer(pointer) {\n            return HEAP16[pointer >> 1];\n          } : function readU16FromPointer(pointer) {\n            return HEAPU16[pointer >> 1];\n          };\n\n        case 2:\n          return signed ? function readS32FromPointer(pointer) {\n            return HEAP32[pointer >> 2];\n          } : function readU32FromPointer(pointer) {\n            return HEAPU32[pointer >> 2];\n          };\n\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n\n    function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {\n      name = readLatin1String(name);\n\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n\n      var shift = getShiftFromSize(size);\n\n      var fromWireType = function fromWireType(value) {\n        return value;\n      };\n\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n\n        fromWireType = function fromWireType(value) {\n          return value << bitshift >>> bitshift;\n        };\n      }\n\n      var isUnsignedType = name.includes(\"unsigned\");\n      registerType(primitiveType, {\n        name: name,\n        \"fromWireType\": fromWireType,\n        \"toWireType\": function toWireType(destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError('Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name);\n          }\n\n          if (value < minRange || value > maxRange) {\n            throw new TypeError('Passing a number \"' + _embind_repr(value) + '\" from JS side to C/C++ side to an argument of type \"' + name + '\", which is outside the valid range [' + minRange + \", \" + maxRange + \"]!\");\n          }\n\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": integerReadValueFromPointer(name, shift, minRange !== 0),\n        destructorFunction: null\n      });\n    }\n\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n      var TA = typeMapping[dataTypeIndex];\n\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": decodeMemoryView,\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": decodeMemoryView\n      }, {\n        ignoreDuplicateRegistrations: true\n      });\n    }\n\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = value + 4;\n\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n\n            str = a.join(\"\");\n          }\n\n          _free(value);\n\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n\n          var getLength;\n          var valueIsOfTypeString = typeof value === \"string\";\n\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function getLength() {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function getLength() {\n              return value.length;\n            };\n          }\n\n          var length = getLength();\n\n          var ptr = _malloc(4 + length + 1);\n\n          HEAPU32[ptr >> 2] = length;\n\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n\n                if (charCode > 255) {\n                  _free(ptr);\n\n                  throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                }\n\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n\n        getHeap = function getHeap() {\n          return HEAPU16;\n        };\n\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n\n        getHeap = function getHeap() {\n          return HEAPU32;\n        };\n\n        shift = 2;\n      }\n\n      registerType(rawType, {\n        name: name,\n        \"fromWireType\": function fromWireType(value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n\n          _free(value);\n\n          return str;\n        },\n        \"toWireType\": function toWireType(destructors, value) {\n          if (!(typeof value === \"string\")) {\n            throwBindingError(\"Cannot pass non-string to C++ string type \" + name);\n          }\n\n          var length = lengthBytesUTF(value);\n\n          var ptr = _malloc(4 + length + charSize);\n\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n\n          return ptr;\n        },\n        \"argPackAdvance\": 8,\n        \"readValueFromPointer\": simpleReadValueFromPointer,\n        destructorFunction: function destructorFunction(ptr) {\n          _free(ptr);\n        }\n      });\n    }\n\n    function __embind_register_value_array(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      tupleRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        elements: []\n      };\n    }\n\n    function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      tupleRegistrations[rawTupleType].elements.push({\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n\n    function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n        rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n        fields: []\n      };\n    }\n\n    function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext\n      });\n    }\n\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        \"argPackAdvance\": 0,\n        \"fromWireType\": function fromWireType() {\n          return undefined;\n        },\n        \"toWireType\": function toWireType(destructors, o) {\n          return undefined;\n        }\n      });\n    }\n\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n\n      if (undefined === impl) {\n        throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n      }\n\n      return impl;\n    }\n\n    function __emval_take_value(type, argv) {\n      type = requireRegisteredType(type, \"_emval_take_value\");\n      var v = type[\"readValueFromPointer\"](argv);\n      return __emval_register(v);\n    }\n\n    function _abort() {\n      abort();\n    }\n\n    var readAsmConstArgsArray = [];\n\n    function readAsmConstArgs(sigPtr, buf) {\n      readAsmConstArgsArray.length = 0;\n      var ch;\n      buf >>= 2;\n\n      while (ch = HEAPU8[sigPtr++]) {\n        var _double = ch < 105;\n\n        if (_double && buf & 1) buf++;\n        readAsmConstArgsArray.push(_double ? HEAPF64[buf++ >> 1] : HEAP32[buf]);\n        ++buf;\n      }\n\n      return readAsmConstArgsArray;\n    }\n\n    function _emscripten_asm_const_int(code, sigPtr, argbuf) {\n      var args = readAsmConstArgs(sigPtr, argbuf);\n      return ASM_CONSTS[code].apply(null, args);\n    }\n\n    function _longjmp(env, value) {\n      _setThrew(env, value || 1);\n\n      throw \"longjmp\";\n    }\n\n    function _emscripten_longjmp(a0, a1) {\n      return _longjmp(a0, a1);\n    }\n\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      var maxHeapSize = 2147483648;\n\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n        var replacement = emscripten_realloc_buffer(newSize);\n\n        if (replacement) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    var ENV = {};\n\n    function getExecutableName() {\n      return thisProgram || \"./this.program\";\n    }\n\n    function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        var lang = ((typeof navigator === \"undefined\" ? \"undefined\" : (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(navigator)) === \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          \"USER\": \"web_user\",\n          \"LOGNAME\": \"web_user\",\n          \"PATH\": \"/\",\n          \"PWD\": \"/\",\n          \"HOME\": \"/home/web_user\",\n          \"LANG\": lang,\n          \"_\": getExecutableName()\n        };\n\n        for (var x in ENV) {\n          env[x] = ENV[x];\n        }\n\n        var strings = [];\n\n        for (var x in env) {\n          strings.push(x + \"=\" + env[x]);\n        }\n\n        getEnvStrings.strings = strings;\n      }\n\n      return getEnvStrings.strings;\n    }\n\n    function _environ_get(__environ, environ_buf) {\n      try {\n        var bufSize = 0;\n        getEnvStrings().forEach(function (string, i) {\n          var ptr = environ_buf + bufSize;\n          HEAP32[__environ + i * 4 >> 2] = ptr;\n          writeAsciiToMemory(string, ptr);\n          bufSize += string.length + 1;\n        });\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      try {\n        var strings = getEnvStrings();\n        HEAP32[penviron_count >> 2] = strings.length;\n        var bufSize = 0;\n        strings.forEach(function (string) {\n          bufSize += string.length + 1;\n        });\n        HEAP32[penviron_buf_size >> 2] = bufSize;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _exit(status) {\n      exit(status);\n    }\n\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doReadv(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var HIGH_OFFSET = 4294967296;\n        var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);\n        var DOUBLE_LIMIT = 9007199254740992;\n\n        if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {\n          return -61;\n        }\n\n        FS.llseek(stream, offset, whence);\n        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = SYSCALLS.doWritev(stream, iov, iovcnt);\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === \"undefined\" || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _getTempRet0() {\n      return getTempRet0();\n    }\n\n    function _setTempRet0(val) {\n      setTempRet0(val);\n    }\n\n    function _writeFP(x, y) {\n      document.addEventListener(\"imageEv\", function () {\n        var canvas = document.getElementById(\"iSet\");\n        var context = canvas.getContext(\"2d\");\n        var centerX = x;\n        var centerY = y;\n        var radius = 10;\n        context.beginPath();\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n        context.lineWidth = 2;\n        context.strokeStyle = \"#34FF19\";\n        context.stroke();\n      });\n    }\n\n    function _writeFS(x, y) {\n      document.addEventListener(\"imageEv\", function () {\n        var canvas = document.getElementById(\"iSet\");\n        var context = canvas.getContext(\"2d\");\n        var centerX = x;\n        var centerY = y;\n        var radius = 4;\n        context.beginPath();\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n        context.lineWidth = 1;\n        context.strokeStyle = \"#FF0119\";\n        context.stroke();\n      });\n    }\n\n    var FSNode = function FSNode(parent, name, mode, rdev) {\n      if (!parent) {\n        parent = this;\n      }\n\n      this.parent = parent;\n      this.mount = parent.mount;\n      this.mounted = null;\n      this.id = FS.nextInode++;\n      this.name = name;\n      this.mode = mode;\n      this.node_ops = {};\n      this.stream_ops = {};\n      this.rdev = rdev;\n    };\n\n    var readMode = 292 | 73;\n    var writeMode = 146;\n    Object.defineProperties(FSNode.prototype, {\n      read: {\n        get: function get() {\n          return (this.mode & readMode) === readMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= readMode : this.mode &= ~readMode;\n        }\n      },\n      write: {\n        get: function get() {\n          return (this.mode & writeMode) === writeMode;\n        },\n        set: function set(val) {\n          val ? this.mode |= writeMode : this.mode &= ~writeMode;\n        }\n      },\n      isFolder: {\n        get: function get() {\n          return FS.isDir(this.mode);\n        }\n      },\n      isDevice: {\n        get: function get() {\n          return FS.isChrdev(this.mode);\n        }\n      }\n    });\n    FS.FSNode = FSNode;\n    FS.staticInit();\n    InternalError = Module[\"InternalError\"] = extendError(Error, \"InternalError\");\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    init_ClassHandle();\n    init_RegisteredPointer();\n    init_embind();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n    init_emval();\n    var ASSERTIONS = false;\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 255) {\n          if (ASSERTIONS) {\n            assert(false, \"Character code \" + chr + \" (\" + String.fromCharCode(chr) + \")  at offset \" + i + \" not in 0x00-0xFF.\");\n          }\n\n          chr &= 255;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join(\"\");\n    }\n\n    var decodeBase64 = typeof atob === \"function\" ? atob : function (input) {\n      var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      var output = \"\";\n      var chr1, chr2, chr3;\n      var enc1, enc2, enc3, enc4;\n      var i = 0;\n      input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      do {\n        enc1 = keyStr.indexOf(input.charAt(i++));\n        enc2 = keyStr.indexOf(input.charAt(i++));\n        enc3 = keyStr.indexOf(input.charAt(i++));\n        enc4 = keyStr.indexOf(input.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 !== 64) {\n          output = output + String.fromCharCode(chr2);\n        }\n\n        if (enc4 !== 64) {\n          output = output + String.fromCharCode(chr3);\n        }\n      } while (i < input.length);\n\n      return output;\n    };\n\n    function intArrayFromBase64(s) {\n      if (typeof ENVIRONMENT_IS_NODE === \"boolean\" && ENVIRONMENT_IS_NODE) {\n        var buf;\n\n        try {\n          buf = Buffer.from(s, \"base64\");\n        } catch (_) {\n          buf = new Buffer(s, \"base64\");\n        }\n\n        return new Uint8Array(buf[\"buffer\"], buf[\"byteOffset\"], buf[\"byteLength\"]);\n      }\n\n      try {\n        var decoded = decodeBase64(s);\n        var bytes = new Uint8Array(decoded.length);\n\n        for (var i = 0; i < decoded.length; ++i) {\n          bytes[i] = decoded.charCodeAt(i);\n        }\n\n        return bytes;\n      } catch (_) {\n        throw new Error(\"Converting base64 string to bytes failed.\");\n      }\n    }\n\n    function tryParseAsDataURI(filename) {\n      if (!isDataURI(filename)) {\n        return;\n      }\n\n      return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n    }\n\n    var asmLibraryArg = {\n      \"V\": ___cxa_allocate_exception,\n      \"U\": ___cxa_throw,\n      \"l\": ___sys_fcntl64,\n      \"C\": ___sys_ioctl,\n      \"D\": ___sys_open,\n      \"M\": __embind_finalize_value_array,\n      \"P\": __embind_finalize_value_object,\n      \"x\": __embind_register_bigint,\n      \"F\": __embind_register_bool,\n      \"L\": __embind_register_class,\n      \"K\": __embind_register_class_constructor,\n      \"f\": __embind_register_class_function,\n      \"E\": __embind_register_emval,\n      \"n\": __embind_register_float,\n      \"q\": __embind_register_function,\n      \"d\": __embind_register_integer,\n      \"c\": __embind_register_memory_view,\n      \"o\": __embind_register_std_string,\n      \"j\": __embind_register_std_wstring,\n      \"O\": __embind_register_value_array,\n      \"N\": __embind_register_value_array_element,\n      \"Q\": __embind_register_value_object,\n      \"p\": __embind_register_value_object_field,\n      \"G\": __embind_register_void,\n      \"I\": __emval_decref,\n      \"J\": __emval_incref,\n      \"H\": __emval_take_value,\n      \"r\": _abort,\n      \"T\": _emscripten_asm_const_int,\n      \"g\": _emscripten_longjmp,\n      \"y\": _emscripten_resize_heap,\n      \"z\": _environ_get,\n      \"A\": _environ_sizes_get,\n      \"e\": _exit,\n      \"m\": _fd_close,\n      \"B\": _fd_read,\n      \"w\": _fd_seek,\n      \"k\": _fd_write,\n      \"b\": _getTempRet0,\n      \"s\": invoke_ii,\n      \"t\": invoke_iii,\n      \"W\": invoke_iiii,\n      \"h\": invoke_vi,\n      \"u\": invoke_vii,\n      \"v\": invoke_viii,\n      \"i\": invoke_viiii,\n      \"a\": _setTempRet0,\n      \"R\": _writeFP,\n      \"S\": _writeFS\n    };\n    var asm = createWasm();\n\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"Y\"]).apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"Z\"]).apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      return (_free = Module[\"_free\"] = Module[\"asm\"][\"_\"]).apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      return (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"$\"]).apply(null, arguments);\n    };\n\n    var ___getTypeName = Module[\"___getTypeName\"] = function () {\n      return (___getTypeName = Module[\"___getTypeName\"] = Module[\"asm\"][\"ba\"]).apply(null, arguments);\n    };\n\n    var ___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = function () {\n      return (___embind_register_native_and_builtin_types = Module[\"___embind_register_native_and_builtin_types\"] = Module[\"asm\"][\"ca\"]).apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"da\"]).apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"ea\"]).apply(null, arguments);\n    };\n\n    var _setThrew = Module[\"_setThrew\"] = function () {\n      return (_setThrew = Module[\"_setThrew\"] = Module[\"asm\"][\"fa\"]).apply(null, arguments);\n    };\n\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"ga\"]).apply(null, arguments);\n    };\n\n    function invoke_ii(index, a1) {\n      var sp = stackSave();\n\n      try {\n        return wasmTable.get(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_vi(index, a1) {\n      var sp = stackSave();\n\n      try {\n        wasmTable.get(index)(a1);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_viii(index, a1, a2, a3) {\n      var sp = stackSave();\n\n      try {\n        wasmTable.get(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_vii(index, a1, a2) {\n      var sp = stackSave();\n\n      try {\n        wasmTable.get(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iii(index, a1, a2) {\n      var sp = stackSave();\n\n      try {\n        return wasmTable.get(index)(a1, a2);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = stackSave();\n\n      try {\n        wasmTable.get(index)(a1, a2, a3, a4);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = stackSave();\n\n      try {\n        return wasmTable.get(index)(a1, a2, a3);\n      } catch (e) {\n        stackRestore(sp);\n        if (e !== e + 0 && e !== \"longjmp\") throw e;\n\n        _setThrew(1, 0);\n      }\n    }\n\n    Module[\"FS\"] = FS;\n    var calledRun;\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n\n    function run(args) {\n      args = args || arguments_;\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      preRun();\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n\n    Module[\"run\"] = run;\n\n    function exit(status, implicit) {\n      EXITSTATUS = status;\n\n      if (implicit && keepRuntimeAlive() && status === 0) {\n        return;\n      }\n\n      if (keepRuntimeAlive()) {} else {\n        exitRuntime();\n        if (Module[\"onExit\"]) Module[\"onExit\"](status);\n        ABORT = true;\n      }\n\n      quit_(status, new ExitStatus(status));\n    }\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [Module[\"preInit\"]];\n\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    run();\n    return arFset.ready;\n  };\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arFset);\n\n//# sourceURL=webpack://ARFset/./build/arfset_ES6_wasm.js?");

/***/ }),

/***/ "./src/ARFset.js":
/*!***********************!*\
  !*** ./src/ARFset.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ARFset)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _build_arfset_ES6_wasm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../build/arfset_ES6_wasm.js */ \"./build/arfset_ES6_wasm.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.js\");\n\n\n\n\n\n/*\n *  ARFset.js\n *  FeatureSet-Display\n *\n *  This file is part of FeatureSet-Display - WebARKit.\n *\n *  FeatureSet-Display is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  FeatureSet-Display is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with FeatureSet-Display.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2021 WebARKit.\n *\n *  Author(s): Walter Perdan @kalwalt https://github.com/kalwalt\n *\n */\n\n\n\nvar ARFset = /*#__PURE__*/function () {\n  function ARFset() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, ARFset);\n\n    this.id = 0;\n    this.nftMarkerCount = 0;\n    this.numIset = 0;\n    this.imageSetWidth = 0;\n    this.imageSetHeight = 0;\n    this.dpi = 0;\n    this.frameIbwpointer = null;\n    this.frameimgBWsize = null;\n    this.frameFeaturePoints = null;\n    this.numFpoints = null;\n    this.canvas = null;\n    this.ctx = null;\n    this.version = '0.2.1';\n    console.log('FeatureSETDisplay version: ', this.version);\n  }\n\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ARFset, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee() {\n        var runtime, scope;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return (0,_build_arfset_ES6_wasm_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n\n              case 2:\n                runtime = _context.sent;\n                this.instance = runtime;\n\n                this._decorate();\n\n                scope = typeof window !== 'undefined' ? window : __webpack_require__.g;\n                scope.arfset = this;\n\n                this._setup();\n\n                return _context.abrupt(\"return\", this);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n\n      return initialize;\n    }()\n  }, {\n    key: \"_decorate\",\n    value: function _decorate() {\n      var _this = this;\n\n      // add delegate methods\n      ['setup', 'FS'].forEach(function (method) {\n        _this[method] = _this.instance[method];\n      });\n    }\n  }, {\n    key: \"_createCanvas\",\n    value: function _createCanvas() {\n      if (typeof document !== \"undefined\") {\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.id = \"iSet\";\n        this.ctx = this.canvas.getContext(\"2d\");\n        console.log('canvas created');\n      }\n\n      ;\n    }\n  }, {\n    key: \"display\",\n    value: function display() {\n      this._createCanvas();\n\n      document.body.appendChild(this.canvas);\n      var self = this;\n      document.addEventListener('nftMarker', function (ev) {\n        self.canvas.width = ev.detail.widthNFT;\n        self.canvas.height = ev.detail.heightNFT;\n        self.numIset = ev.detail.numIset;\n        self.imageSetWidth = ev.detail.widthNFT;\n        self.imageSetHeight = ev.detail.heightNFT;\n        self.frameFeaturePoints = ev.detail.pointerFeaturePoints;\n        self.numFpoints = ev.detail.numFpoints;\n        self.dpi = ev.detail.dpi;\n        var debugBuffer = new Uint8ClampedArray(self.instance.HEAPU8.buffer, self.frameIbwpointer, self.frameimgBWsize);\n        var pointerFeaturePoints = new Uint16Array(self.instance.HEAPU16.buffer, self.frameFeaturePoints, self.numFpoints * 2);\n        var id = new ImageData(new Uint8ClampedArray(self.canvas.width * self.canvas.height * 4), self.canvas.width, self.canvas.height);\n\n        for (var i = 0, j = 0; i < debugBuffer.length; i++, j += 4) {\n          var v = debugBuffer[i];\n          id.data[j + 0] = v;\n          id.data[j + 1] = v;\n          id.data[j + 2] = v;\n          id.data[j + 3] = 255;\n        }\n\n        self.ctx.putImageData(id, 0, 0);\n        var imageEv = new Event('imageEv');\n        document.dispatchEvent(imageEv);\n\n        self.instance._free(debugBuffer);\n      });\n    }\n  }, {\n    key: \"loadNFTMarker\",\n    value: function () {\n      var _loadNFTMarker = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(urlOrData) {\n        var _this2 = this;\n\n        var nft;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.addNFTMarker(this.id, urlOrData).then(function (nftMarker) {\n                  console.log(nftMarker);\n                  var params = arfset.frameMalloc;\n                  _this2.frameIbwpointer = params.frameIbwpointer;\n                  _this2.frameimgBWsize = params.frameimgBWsize;\n                  var nftEvent = new CustomEvent('nftMarker', {\n                    detail: {\n                      numIset: nftMarker.numIset,\n                      widthNFT: nftMarker.width,\n                      heightNFT: nftMarker.height,\n                      dpi: nftMarker.dpi,\n                      numFpoints: nftMarker.numFpoints,\n                      pointerFeaturePoints: nftMarker.nftFeaturePoints,\n                      nftPoints: nftMarker.nftPoints\n                    }\n                  });\n                  document.dispatchEvent(nftEvent);\n                  _this2.nftMarkerCount = nftMarker.id + 1;\n                });\n\n              case 2:\n                nft = _context2.sent;\n                return _context2.abrupt(\"return\", nft);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function loadNFTMarker(_x) {\n        return _loadNFTMarker.apply(this, arguments);\n      }\n\n      return loadNFTMarker;\n    }()\n  }, {\n    key: \"loadNFTMarkerBlob\",\n    value: function () {\n      var _loadNFTMarkerBlob = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(urlOrData) {\n        var _this3 = this;\n\n        var nft;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.addNFTMarkerBlob(this.id, urlOrData).then(function (nftMarker) {\n                  console.log(nftMarker);\n                  var params = arfset.frameMalloc;\n                  _this3.frameIbwpointer = params.frameIbwpointer;\n                  _this3.frameimgBWsize = params.frameimgBWsize;\n                  var nftEvent = new CustomEvent('nftMarker', {\n                    detail: {\n                      numIset: nftMarker.numIset,\n                      widthNFT: nftMarker.width,\n                      heightNFT: nftMarker.height,\n                      dpi: nftMarker.dpi,\n                      numFpoints: nftMarker.numFpoints,\n                      pointerFeaturePoints: nftMarker.nftFeaturePoints,\n                      nftPoints: nftMarker.nftPoints\n                    }\n                  });\n                  document.dispatchEvent(nftEvent);\n                  _this3.nftMarkerCount = nftMarker.id + 1;\n                });\n\n              case 2:\n                nft = _context3.sent;\n                return _context3.abrupt(\"return\", nft);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function loadNFTMarkerBlob(_x2) {\n        return _loadNFTMarkerBlob.apply(this, arguments);\n      }\n\n      return loadNFTMarkerBlob;\n    }()\n  }, {\n    key: \"addNFTMarker\",\n    value: function () {\n      var _addNFTMarker = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee5(arId, url) {\n        var targetPrefix, extensions, storeMarker, promises;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // url doesn't need to be a valid url. Extensions to make it valid will be added here\n                targetPrefix = '/markerNFT_' + this.markerNFTCount++;\n                extensions = ['fset', 'iset', 'fset3'];\n\n                storeMarker = /*#__PURE__*/function () {\n                  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(ext) {\n                    var fullUrl, target, data;\n                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            fullUrl = url + '.' + ext;\n                            target = targetPrefix + '.' + ext;\n                            _context4.next = 4;\n                            return _Utils__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fetchRemoteData(fullUrl);\n\n                          case 4:\n                            data = _context4.sent;\n\n                            this._storeDataFile(data, target);\n\n                          case 6:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, this);\n                  }));\n\n                  return function storeMarker(_x5) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                promises = extensions.map(storeMarker, this);\n                _context5.next = 6;\n                return Promise.all(promises);\n\n              case 6:\n                return _context5.abrupt(\"return\", this.instance._readNFTMarker(arId, targetPrefix));\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function addNFTMarker(_x3, _x4) {\n        return _addNFTMarker.apply(this, arguments);\n      }\n\n      return addNFTMarker;\n    }()\n  }, {\n    key: \"addNFTMarkerBlob\",\n    value: function () {\n      var _addNFTMarkerBlob = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee7(arId, urlOrData) {\n        var targetPrefix, extensions, storeMarker, promises;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // url doesn't need to be a valid url. Extensions to make it valid will be added here\n                console.log(urlOrData);\n                targetPrefix = '/markerNFT_' + this.markerNFTCount++;\n                extensions = ['fset', 'iset', 'fset3'];\n\n                storeMarker = /*#__PURE__*/function () {\n                  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee6(ext, i) {\n                    var fullUrl, target, data;\n                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            //const fullUrl = url + '.' + ext\n                            console.log(i);\n                            fullUrl = urlOrData[i];\n                            console.log(fullUrl);\n                            target = targetPrefix + '.' + ext;\n                            _context6.next = 6;\n                            return _Utils__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fetchRemoteDataBlob(fullUrl);\n\n                          case 6:\n                            data = _context6.sent;\n\n                            this._storeDataFile(data, target);\n\n                          case 8:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6, this);\n                  }));\n\n                  return function storeMarker(_x8, _x9) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                promises = extensions.map(storeMarker, this);\n                _context7.next = 7;\n                return Promise.all(promises);\n\n              case 7:\n                return _context7.abrupt(\"return\", this.instance._readNFTMarker(arId, targetPrefix));\n\n              case 8:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function addNFTMarkerBlob(_x6, _x7) {\n        return _addNFTMarkerBlob.apply(this, arguments);\n      }\n\n      return addNFTMarkerBlob;\n    }() // ---------------------------------------------------------------------------\n    // implementation\n\n  }, {\n    key: \"_storeDataFile\",\n    value: function _storeDataFile(data, target) {\n      // FS is provided by emscripten\n      // Note: valid data must be in binary format encoded as Uint8Array\n      this.instance.FS.writeFile(target, data, {\n        encoding: 'binary'\n      });\n    }\n  }, {\n    key: \"_setup\",\n    value: function _setup() {\n      // we need to start with a memory dimension.\n      // Memory can be enlarged thanks to MEMORY_ALLOW_GROWTH option.\n      var width = 893;\n      var height = 1117;\n      this.id = this.instance.setup(width, height);\n    }\n  }]);\n\n  return ARFset;\n}();\n\n\n\n//# sourceURL=webpack://ARFset/./src/ARFset.js?");

/***/ }),

/***/ "./src/Utils.js":
/*!**********************!*\
  !*** ./src/Utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Utils)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n/*\n *  Utils.js\n *  FeatureSet-Display\n *\n *  This file is part of FeatureSet-Display - WebARKit.\n *\n *  FeatureSet-Display is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  FeatureSet-Display is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with FeatureSet-Display.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2021 WebARKit.\n *\n *  Author(s): Walter Perdan @kalwalt https://github.com/kalwalt\n *\n */\n\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, Utils);\n  }\n\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, null, [{\n    key: \"fetchRemoteDataBlob\",\n    value: function () {\n      var _fetchRemoteDataBlob = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(urlOrData) {\n        var data, response;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(urlOrData.indexOf(\"\\n\") !== -1)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                // assume text from a .patt file\n                data = Utils.string2Uint8Data(urlOrData);\n                console.log(data);\n                return _context.abrupt(\"return\", data);\n\n              case 6:\n                _context.prev = 6;\n                _context.next = 9;\n                return axios__WEBPACK_IMPORTED_MODULE_4___default().get(urlOrData, {\n                  responseType: 'arraybuffer'\n                });\n\n              case 9:\n                response = _context.sent;\n                console.log(response);\n                return _context.abrupt(\"return\", new Uint8Array(response.data));\n\n              case 14:\n                _context.prev = 14;\n                _context.t0 = _context[\"catch\"](6);\n                throw _context.t0;\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[6, 14]]);\n      }));\n\n      function fetchRemoteDataBlob(_x) {\n        return _fetchRemoteDataBlob.apply(this, arguments);\n      }\n\n      return fetchRemoteDataBlob;\n    }()\n  }, {\n    key: \"fetchRemoteData\",\n    value: function () {\n      var _fetchRemoteData = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(url) {\n        var response;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return axios__WEBPACK_IMPORTED_MODULE_4___default().get(url, {\n                  responseType: 'arraybuffer'\n                });\n\n              case 3:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", new Uint8Array(response.data));\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw _context2.t0;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 7]]);\n      }));\n\n      function fetchRemoteData(_x2) {\n        return _fetchRemoteData.apply(this, arguments);\n      }\n\n      return fetchRemoteData;\n    }()\n  }, {\n    key: \"fetchRemoteDataCallback\",\n    value: function () {\n      var _fetchRemoteDataCallback = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(url, callback) {\n        var response;\n        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return axios__WEBPACK_IMPORTED_MODULE_4___default().get(url, {\n                  responseType: 'arraybuffer'\n                }).then(function (response) {\n                  data = new Uint8Array(response.data);\n                  console.log(data);\n                  callback(response);\n                });\n\n              case 3:\n                response = _context3.sent;\n                return _context3.abrupt(\"return\", response);\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n                throw _context3.t0;\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[0, 7]]);\n      }));\n\n      function fetchRemoteDataCallback(_x3, _x4) {\n        return _fetchRemoteDataCallback.apply(this, arguments);\n      }\n\n      return fetchRemoteDataCallback;\n    }()\n  }, {\n    key: \"string2Uint8Data\",\n    value: function string2Uint8Data(string) {\n      var data = new Uint8Array(string.length);\n\n      for (var i = 0; i < data.length; i++) {\n        data[i] = string.charCodeAt(i) & 0xff;\n      }\n\n      return data;\n    }\n  }]);\n\n  return Utils;\n}();\n\n\n\n//# sourceURL=webpack://ARFset/./src/Utils.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ARFset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ARFset */ \"./src/ARFset.js\");\n/*\n *  index.js\n *  FeatureSet-Display\n *\n *  This file is part of FeatureSet-Display - WebARKit.\n *\n *  FeatureSet-Display is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  FeatureSet-Display is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with FeatureSet-Display.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  As a special exception, the copyright holders of this library give you\n *  permission to link this library with independent modules to produce an\n *  executable, regardless of the license terms of these independent modules, and to\n *  copy and distribute the resulting executable under terms of your choice,\n *  provided that you also meet, for each linked independent module, the terms and\n *  conditions of the license of that module. An independent module is a module\n *  which is neither derived from nor based on this library. If you modify this\n *  library, you may extend this exception to your version of the library, but you\n *  are not obligated to do so. If you do not wish to do so, delete this exception\n *  statement from your version.\n *\n *  Copyright 2021 WebARKit.\n *\n *  Author(s): Walter Perdan @kalwalt https://github.com/kalwalt\n *\n */\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  ARFset: _ARFset__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n});\n\n//# sourceURL=webpack://ARFset/./src/index.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n\n\n//# sourceURL=webpack://ARFset/./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "?deb7":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ARFset/crypto_(ignored)?");

/***/ }),

/***/ "?4dea":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ARFset/fs_(ignored)?");

/***/ }),

/***/ "?f955":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ARFset/path_(ignored)?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _asyncToGenerator)\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\n//# sourceURL=webpack://ARFset/./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _classCallCheck)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n//# sourceURL=webpack://ARFset/./node_modules/@babel/runtime/helpers/esm/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _createClass)\n/* harmony export */ });\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n//# sourceURL=webpack://ARFset/./node_modules/@babel/runtime/helpers/esm/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ _typeof)\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n//# sourceURL=webpack://ARFset/./node_modules/@babel/runtime/helpers/esm/typeof.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});